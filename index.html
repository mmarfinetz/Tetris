<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multiplayer Tetris Battle</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            /* Allow vertical scrolling so the population panel can sit below */
            overflow-x: hidden;
            overflow-y: auto;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }

        #gameContainer {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            padding: 20px;
            max-width: 1400px;
            width: 100%;
            justify-content: center;
        }

        .playerSection {
            background: rgba(0, 0, 0, 0.7);
            border-radius: 15px;
            padding: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            position: relative;
        }

        .playerSection.main {
            order: 2;
            /* All players same size */
        }

        .playerHeader {
            text-align: center;
            margin-bottom: 10px;
            padding: 10px;
            background: linear-gradient(90deg, #f093fb 0%, #f5576c 100%);
            border-radius: 10px;
            font-weight: bold;
            font-size: 18px;
        }

        .gameBoard {
            position: relative;
            border: 3px solid #fff;
            border-radius: 5px;
            background: rgba(0, 0, 0, 0.9);
            display: inline-block;
        }

        /* All players get same size canvases now */

        canvas {
            display: block;
            image-rendering: pixelated;
            width: 200px;
            height: 400px;
        }

        .stats {
            margin-top: 10px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            font-size: 14px;
        }

        .stats div {
            margin: 5px 0;
            display: flex;
            justify-content: space-between;
        }

        .powerUpsContainer {
            margin-top: 15px;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
        }

        .powerUp {
            width: 60px;
            height: 60px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: 2px solid #fff;
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }

        .powerUp:hover {
            transform: scale(1.1);
            box-shadow: 0 5px 20px rgba(255, 255, 255, 0.3);
        }

        .powerUp.active {
            animation: pulse 1s infinite;
        }

        .powerUp.cooldown {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .powerUp .icon {
            font-size: 24px;
            margin-bottom: 2px;
        }

        .powerUp .name {
            font-size: 9px;
            text-align: center;
        }

        .powerUp .cooldownTimer {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 20px;
            font-weight: bold;
            color: #ff0;
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(255, 255, 255, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(255, 255, 255, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 255, 255, 0); }
        }

        #startMenu {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .menuTitle {
            font-size: 48px;
            margin-bottom: 30px;
            background: linear-gradient(90deg, #f093fb 0%, #f5576c 100%);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-align: center;
        }

        .menuButtons {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .menuButton {
            padding: 15px 40px;
            font-size: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            color: white;
            border-radius: 30px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .menuButton:hover {
            transform: scale(1.05);
            box-shadow: 0 10px 30px rgba(102, 126, 234, 0.5);
        }

        .controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            z-index: 100;
        }

        .controls h3 {
            margin-bottom: 10px;
        }

        .controlsGrid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            font-size: 12px;
        }

        .effect {
            position: absolute;
            pointer-events: none;
            z-index: 500;
        }

        .lineCleared {
            position: absolute;
            background: linear-gradient(90deg, transparent, #fff, transparent);
            height: 20px;
            width: 100%;
            animation: lineClear 0.5s ease-out;
        }

        @keyframes lineClear {
            0% { 
                transform: scaleX(0);
                opacity: 1;
            }
            100% { 
                transform: scaleX(1);
                opacity: 0;
            }
        }

        .attackIndicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 30px;
            color: #ff0;
            font-weight: bold;
            animation: attackPulse 1s ease-out;
            pointer-events: none;
            z-index: 600;
        }

        @keyframes attackPulse {
            0% {
                transform: translate(-50%, -50%) scale(0);
                opacity: 1;
            }
            50% {
                transform: translate(-50%, -50%) scale(1.5);
            }
            100% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 0;
            }
        }

        .targetSelector {
            margin-top: 10px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
        }

        .targetButton {
            padding: 5px 10px;
            margin: 5px;
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid #fff;
            color: white;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .targetButton.selected {
            background: rgba(255, 100, 100, 0.5);
            transform: scale(1.1);
        }

        @media (max-width: 768px) {
            #gameContainer {
                flex-direction: column;
                align-items: center;
            }
            
            .playerSection.main {
                transform: scale(1);
            }
            
            canvas {
                width: 100%;
                max-width: 200px;
                height: auto;
            }
            
            .controls {
                width: 90%;
                font-size: 10px;
            }
        }

        /* Population preview panel (mini transparent boards) */
        #populationPanel {
            flex-basis: 100%;
            max-width: 1400px;
            width: 100%;
            margin-top: 8px;
            background: rgba(0, 0, 0, 0.35);
            border-radius: 12px;
            padding: 12px 12px 16px 12px;
            box-shadow: 0 6px 24px rgba(0,0,0,0.35);
        }
        .populationHeader {
            font-weight: 700;
            font-size: 16px;
            opacity: 0.9;
            margin: 2px 0 10px 2px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .populationGrid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 10px;
        }
        .miniCard {
            background: rgba(255,255,255,0.06);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 10px;
            padding: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }
        .miniCard:hover { 
            transform: translateY(-2px);
            box-shadow: 0 6px 18px rgba(0,0,0,0.3);
        }
        .miniCard.dead {
            border-color: rgba(255,50,50,0.4);
            opacity: 0.6;
            background: rgba(40,10,10,0.3);
        }
        .miniLabel {
            font-size: 11px;
            opacity: 0.9;
            margin-bottom: 6px;
        }
        .miniStats {
            font-size: 10px;
            opacity: 0.8;
            margin-top: 6px;
        }
        canvas.mini {
            display: block;
            image-rendering: pixelated;
            width: 100px;
            height: 200px;
            opacity: 0.85;
            border-radius: 6px;
            border: 1px solid rgba(255,255,255,0.25);
            background: radial-gradient(120px 240px at 50% 50%, rgba(255,255,255,0.06), rgba(0,0,0,0.25));
        }
    </style>
</head>
<body>
    <div id="startMenu">
        <h1 class="menuTitle">TETRIS BATTLE</h1>
        <div class="menuButtons">
            <button class="menuButton" onclick="startGame(4, 'genetic')">4 Players (Genetic AI)</button>
            <button class="menuButton" onclick="startGame(4, 'markov')">4 Players (Markov Chain AI)</button>
            <button class="menuButton" onclick="startGame(4, 'mixed')">4 Players (Mixed AI)</button>
            <button class="menuButton" onclick="startGame(4, 'versus')">4 Players (AI vs AI: Markov vs Genetic)</button>
        </div>
        <div style="margin-top: 16px; font-size: 16px; display: flex; align-items: center; gap: 8px;">
            <input id="togglePowerUps" type="checkbox" checked style="transform: scale(1.2);" />
            <label for="togglePowerUps">Enable Power-ups</label>
        </div>
    </div>

    <div id="gameContainer" style="display: none;">
        <!-- Player sections will be generated dynamically -->
    </div>

    <div class="controls" style="display: none;">
        <h3>Controls</h3>
        <div class="controlsGrid">
            <div>‚¨ÖÔ∏è‚û°Ô∏è Move</div>
            <div>‚¨áÔ∏è Soft Drop</div>
            <div>‚¨ÜÔ∏è Rotate</div>
            <div>Space: Hard Drop</div>
            <div>1-5: Power-ups</div>
            <div>Tab: Change Target</div>
        </div>
    </div>

    <script>
        // Game Constants
        const BOARD_WIDTH = 10;
        const BOARD_HEIGHT = 20;
        const BLOCK_SIZE = 20;
        const COLORS = {
            I: '#00f0f0',
            O: '#f0f000',
            T: '#a000f0',
            S: '#00f000',
            Z: '#f00000',
            J: '#0000f0',
            L: '#f0a000',
            EMPTY: '#000',
            GHOST: 'rgba(255, 255, 255, 0.2)'
        };

        // Tetromino definitions
        const PIECES = {
            I: [[1,1,1,1]],
            O: [[1,1],[1,1]],
            T: [[0,1,0],[1,1,1]],
            S: [[0,1,1],[1,1,0]],
            Z: [[1,1,0],[0,1,1]],
            J: [[1,0,0],[1,1,1]],
            L: [[0,0,1],[1,1,1]]
        };

        // Power-up definitions
        const POWERUPS = {
            GARBAGE: { name: 'Garbage', icon: 'üóëÔ∏è', type: 'offensive' },
            SPEED: { name: 'Speed', icon: '‚ö°', type: 'offensive' },
            BLIND: { name: 'Blind', icon: 'üëÅÔ∏è', type: 'offensive' },
            SCRAMBLE: { name: 'Scramble', icon: 'üîÄ', type: 'offensive' },
            GRAVITY: { name: 'Gravity', icon: 'üîÑ', type: 'offensive' },
            SHIELD: { name: 'Shield', icon: 'üõ°Ô∏è', type: 'defensive' },
            CLEAR: { name: 'Clear', icon: 'üí£', type: 'defensive' },
            SLOW: { name: 'Slow', icon: 'üêå', type: 'defensive' },
            GHOST: { name: 'Ghost', icon: 'üëª', type: 'defensive' },
            FREEZE: { name: 'Freeze', icon: '‚ùÑÔ∏è', type: 'defensive' },
            STEAL: { name: 'Steal', icon: 'üéØ', type: 'special' },
            MIRROR: { name: 'Mirror', icon: 'ü™û', type: 'special' },
            ELIMINATE: { name: 'Stack', icon: 'üìö', type: 'offensive' }
        };
        // Only these power-ups have concrete effects implemented below
        const IMPLEMENTED_POWERUPS = ['GARBAGE','SPEED','BLIND','SHIELD','CLEAR','SLOW','ELIMINATE'];

        // -------- Simple Learning AI (Heuristic + Evolution) --------
        const AI_STORAGE_KEY = 'tetris_ai_weights_v2_population';
        
        // -------- Markov Chain AI --------
        const MARKOV_STORAGE_KEY = 'tetris_markov_chains_v2_human_learned';
        const MARKOV_DEFAULTS = {
            stateHistorySize: 1000,    // How many state transitions to remember
            minObservations: 3,        // Minimum observations before using chain (lowered since learning from expert)
            humanMimicRate: 0.3,       // How often to follow learned human patterns vs exploring (lowered since no initial data)
            explorationRate: 0.1,      // Chance to make exploratory move (reduced since heuristics are now good)
            stateSimplification: 'features', // 'features' or 'positions'
            learnFromHuman: true       // Whether to learn from human player
        };
        const DEFAULT_WEIGHTS = {
            // Lower is better for these costs
            aggregateHeight: -0.510066,
            completeLines: 0.760666,
            holes: -0.35663,
            bumpiness: -0.184483
        };

        const GA_DEFAULTS = {
            populationSize: 12,
            tournamentSize: 3,
            mutationRate: 0.15,
            mutationStrength: 0.08,
            crossoverRate: 0.7
        };

        function loadAIWeights() {
            try {
                const saved = localStorage.getItem(AI_STORAGE_KEY);
                if (!saved) return { population: seedPopulation(), index: 0, history: [] };
                const parsed = JSON.parse(saved);
                if (!parsed.population) return { population: seedPopulation(), index: 0, history: [] };
                // Reset evaluation status for new game session
                parsed.population.forEach(genome => {
                    genome.evaluated = false;
                    genome.assigned = false;
                });
                return parsed;
            } catch (_) {
                return { population: seedPopulation(), index: 0, history: [] };
            }
        }

        function saveAIWeights(state) {
            try {
                localStorage.setItem(AI_STORAGE_KEY, JSON.stringify(state));
            } catch (_) {}
        }

        function mutateWeights(base, strength = GA_DEFAULTS.mutationStrength) {
            const mutated = { ...base };
            Object.keys(mutated).forEach(k => {
                if (Math.random() < GA_DEFAULTS.mutationRate) {
                    const delta = (Math.random() * 2 - 1) * strength * Math.max(1, Math.abs(mutated[k]));
                    mutated[k] += delta;
                }
            });
            return mutated;
        }

        function seedPopulation() {
            const pop = [];
            for (let i = 0; i < GA_DEFAULTS.populationSize; i++) {
                pop.push({ id: i, weights: mutateWeights({ ...DEFAULT_WEIGHTS }, 0.2), fitness: 0, evaluated: false });
            }
            return pop;
        }

        function tournamentSelect(population, k = GA_DEFAULTS.tournamentSize) {
            let best = null;
            for (let i = 0; i < k; i++) {
                const ind = population[Math.floor(Math.random() * population.length)];
                if (!best || ind.fitness > best.fitness) best = ind;
            }
            return best;
        }

        function crossoverWeights(a, b) {
            if (Math.random() > GA_DEFAULTS.crossoverRate) return { ...a };
            const child = {};
            const keys = Object.keys(a);
            const pivot = Math.floor(Math.random() * keys.length);
            keys.forEach((k, idx) => {
                child[k] = idx < pivot ? a[k] : b[k];
            });
            return child;
        }

        function evaluateBoardHeuristic(board) {
            return evaluateBoardHeuristicWith(board, loadAIWeights());
        }

        function evaluateBoardHeuristicWith(board, w) {
            const h = computeBoardFeatures(board);
            // Higher score is better
            return (
                w.completeLines * h.completeLines +
                w.aggregateHeight * h.aggregateHeight +
                w.holes * h.holes +
                w.bumpiness * h.bumpiness
            );
        }

        function computeBoardFeatures(board) {
            let aggregateHeight = 0;
            let holes = 0;
            let bumpiness = 0;
            let completeLines = 0;

            const heights = new Array(BOARD_WIDTH).fill(0);

            for (let y = 0; y < BOARD_HEIGHT; y++) {
                let filled = true;
                for (let x = 0; x < BOARD_WIDTH; x++) {
                    if (!board[y][x]) filled = false;
                }
                if (filled) completeLines++;
            }

            for (let x = 0; x < BOARD_WIDTH; x++) {
                let y;
                for (y = 0; y < BOARD_HEIGHT; y++) {
                    if (board[y][x]) break;
                }
                heights[x] = BOARD_HEIGHT - y;
                aggregateHeight += heights[x];

                // Count holes below first block
                let blockSeen = false;
                for (let yy = 0; yy < BOARD_HEIGHT; yy++) {
                    if (board[yy][x]) blockSeen = true;
                    else if (blockSeen) holes++;
                }
            }

            for (let x = 0; x < BOARD_WIDTH - 1; x++) {
                bumpiness += Math.abs(heights[x] - heights[x + 1]);
            }

            return { aggregateHeight, holes, bumpiness, completeLines };
        }

        function cloneBoard(board) {
            return board.map(row => row.slice());
        }

        // -------- Markov Chain AI Implementation --------
        function loadMarkovChains() {
            try {
                const saved = localStorage.getItem(MARKOV_STORAGE_KEY);
                if (!saved) return initializeMarkovChains();
                
                const parsed = JSON.parse(saved);
                if (!parsed || !parsed.chains) return initializeMarkovChains();
                
                // Reconstruct Maps from saved data
                const chains = {
                    stateTransitions: new Map(),
                    stateHistory: parsed.chains.stateHistory || [],
                    totalObservations: parsed.chains.totalObservations || 0,
                    humanPatterns: new Map(),
                    humanGamesObserved: parsed.chains.humanGamesObserved || 0
                };
                
                // Restore stateTransitions Map if it exists
                if (parsed.chains.stateTransitions) {
                    for (const [state, actions] of Object.entries(parsed.chains.stateTransitions)) {
                        chains.stateTransitions.set(state, new Map(Object.entries(actions)));
                    }
                }
                
                // Restore humanPatterns Map if it exists
                if (parsed.chains.humanPatterns) {
                    for (const [state, actions] of Object.entries(parsed.chains.humanPatterns)) {
                        chains.humanPatterns.set(state, new Map(Object.entries(actions)));
                    }
                }
                
                return chains;
            } catch (e) {
                console.error('Error loading Markov chains:', e);
                return initializeMarkovChains();
            }
        }

        function saveMarkovChains(chains) {
            try {
                // Convert Maps to objects for JSON serialization
                const serializable = {
                    stateTransitions: {},
                    stateHistory: chains.stateHistory || [],
                    totalObservations: chains.totalObservations || 0,
                    humanPatterns: {},
                    humanGamesObserved: chains.humanGamesObserved || 0
                };
                
                // Convert stateTransitions Map to object
                if (chains.stateTransitions) {
                    for (const [state, actionMap] of chains.stateTransitions.entries()) {
                        serializable.stateTransitions[state] = {};
                        for (const [action, data] of actionMap.entries()) {
                            serializable.stateTransitions[state][action] = data;
                        }
                    }
                }
                
                // Convert humanPatterns Map to object
                if (chains.humanPatterns) {
                    for (const [state, actionMap] of chains.humanPatterns.entries()) {
                        serializable.humanPatterns[state] = {};
                        for (const [action, count] of actionMap.entries()) {
                            serializable.humanPatterns[state][action] = count;
                        }
                    }
                }
                
                localStorage.setItem(MARKOV_STORAGE_KEY, JSON.stringify({
                    chains: serializable,
                    lastUpdated: Date.now()
                }));
            } catch (e) {
                console.error('Error saving Markov chains:', e);
            }
        }

        function initializeMarkovChains() {
            return {
                stateTransitions: new Map(),    // Map of state -> Map of actions -> probability
                stateHistory: [],               // Recent state-action pairs
                totalObservations: 0,
                humanPatterns: new Map(),       // Map of state -> Map of actions -> count (from human player)
                humanGamesObserved: 0          // Number of games learned from human
            };
        }

        function simplifyBoardToState(board, pieceType = null, nextPieceType = null) {
            // Convert board to a simplified state representation
            const features = computeBoardFeatures(board);
            
            // Discretize features into ranges for state representation
            const heightCategory = Math.floor(features.aggregateHeight / 20); // 0-19, 20-39, etc.
            const holeCategory = Math.min(features.holes, 10); // 0-10+ holes
            const bumpCategory = Math.floor(features.bumpiness / 5); // 0-4, 5-9, etc.
            const lineCategory = features.completeLines; // 0, 1, 2, 3, 4 (usually 0 before drop)
            
            // Include current piece type in the key if provided to disambiguate actions across pieces
            const piecePrefix = pieceType ? `p${pieceType}_` : '';
            const nextPrefix = nextPieceType ? `n${nextPieceType}_` : '';
            return `${piecePrefix}${nextPrefix}h${heightCategory}_o${holeCategory}_b${bumpCategory}_l${lineCategory}`;
        }

        function actionToString(targetX, rotationIndex) {
            return `${targetX}_${rotationIndex}`;
        }

        function updateMarkovChain(chains, prevState, action, currentState, reward) {
            if (!chains.stateTransitions.has(prevState)) {
                chains.stateTransitions.set(prevState, new Map());
            }
            
            const actionMap = chains.stateTransitions.get(prevState);
            if (!actionMap.has(action)) {
                actionMap.set(action, { count: 0, totalReward: 0 });
            }
            
            const actionData = actionMap.get(action);
            actionData.count++;
            actionData.totalReward += reward;
            chains.totalObservations++;
            
            // Keep history limited
            chains.stateHistory.push({ prevState, action, currentState, reward });
            if (chains.stateHistory.length > MARKOV_DEFAULTS.stateHistorySize) {
                chains.stateHistory.shift();
            }
            
            saveMarkovChains(chains);
        }

        function selectMarkovAction(chains, currentState, possibleActions, useHumanPatterns = true, playerId = null, board = null, pieceType = null) {
            // Validate inputs
            if (!board || !pieceType) {
                console.warn(`Markov AI: Missing critical data - board: ${!!board}, pieceType: ${pieceType}`);
            }
            
            // Exploration: sometimes make random moves to discover new patterns
            if (Math.random() < MARKOV_DEFAULTS.explorationRate) {
                return selectActionWithBasicHeuristics(possibleActions, board, pieceType);
            }
            
            // Use human-learned patterns if available and we want to mimic them
            if (useHumanPatterns && chains.humanPatterns && chains.humanPatterns.size > 0 && 
                Math.random() < MARKOV_DEFAULTS.humanMimicRate) {
                const humanAction = selectHumanLearnedAction(chains, currentState, possibleActions);
                if (humanAction) return humanAction;
            }
            
            // Check if we have data for this state
            if (!chains.stateTransitions.has(currentState)) {
                // If no data, try similar states or use basic heuristics
                return selectFromSimilarStates(chains, currentState, possibleActions, board, pieceType);
            }
            
            const actionMap = chains.stateTransitions.get(currentState);
            let bestAction = null;
            let bestScore = -Infinity;
            let foundLearnedAction = false;
            
            // Score each possible action based on historical performance
            for (const action of possibleActions) {
                if (actionMap.has(action) && actionMap.get(action).count >= MARKOV_DEFAULTS.minObservations) {
                    const data = actionMap.get(action);
                    const avgReward = data.totalReward / data.count;
                    const confidence = Math.min(data.count / 20, 1); // Confidence based on observations
                    const score = avgReward * confidence;
                    
                    if (score > bestScore) {
                        bestScore = score;
                        bestAction = action;
                        foundLearnedAction = true;
                    }
                }
            }
            
            // Check if we found a learned action and should celebrate
            if (foundLearnedAction && bestAction && playerId !== null) {
                const player = game && game.players ? game.players.find(p => p.id === playerId) : null;
                if (player && !player.markovInitialized) {
                    const totalStates = chains.stateTransitions.size;
                    const totalObservations = chains.totalObservations;
                    console.log(`üß† CPU ${playerId} (MC): Markov initialized, it's on motherfucker! üöÄ`);
                    console.log(`   üìä Stats: ${totalStates} states learned, ${totalObservations} total observations`);
                    player.markovInitialized = true;
                }
            }
            
            // If no good historical data, use smart fallback
            return bestAction || selectFromSimilarStates(chains, currentState, possibleActions, board, pieceType);
        }

        function selectHumanLearnedAction(chains, currentState, possibleActions) {
            // Prioritize actions that humans have taken in similar situations
            if (!chains.humanPatterns) return null;
            
            const statePattern = chains.humanPatterns.get(currentState);
            if (statePattern) {
                // Return the most common human action for this state
                let bestAction = null;
                let bestCount = 0;
                for (const [action, count] of statePattern.entries()) {
                    if (possibleActions.includes(action) && count > bestCount) {
                        bestCount = count;
                        bestAction = action;
                    }
                }
                return bestAction;
            }
            return null;
        }

        function selectFromSimilarStates(chains, currentState, possibleActions, board = null, pieceType = null) {
            // Find similar states and use their best actions
            const stateFeatures = currentState.split('_');
            let bestAction = null;
            let bestScore = -Infinity;
            
            // Look for states with similar characteristics
            for (const [state, actionMap] of chains.stateTransitions.entries()) {
                const similarity = calculateStateSimilarity(currentState, state);
                if (similarity > 0.7) {  // 70% similarity threshold
                    for (const action of possibleActions) {
                        if (actionMap.has(action)) {
                            const data = actionMap.get(action);
                            const avgReward = data.totalReward / data.count;
                            const score = avgReward * similarity;
                            if (score > bestScore) {
                                bestScore = score;
                                bestAction = action;
                            }
                        }
                    }
                }
            }
            
            // Better fallback: use smart heuristics with board evaluation
            if (!bestAction && possibleActions.length > 0) {
                bestAction = selectActionWithBasicHeuristics(possibleActions, board, pieceType);
            }
            return bestAction;
        }

        function selectActionWithBasicHeuristics(possibleActions, board = null, pieceType = null) {
            // Use REAL Tetris strategy when no learned data exists
            if (!board || !pieceType || possibleActions.length === 0) {
                console.error('CRITICAL: Markov Chain AI missing data!', {
                    hasBoard: !!board,
                    pieceType: pieceType,
                    actionsCount: possibleActions.length,
                    actions: possibleActions.slice(0, 5)
                });
                // Better fallback: prefer center positions and minimal rotations
                const centerActions = possibleActions.filter(a => {
                    const [x, r] = a.split('_').map(Number);
                    return x >= 3 && x <= 6 && r <= 1;
                });
                if (centerActions.length > 0) {
                    return centerActions[0];
                }
                return possibleActions[0] || '4_0'; // Default to center with no rotation
            }
            
            let bestAction = possibleActions[0];
            let bestScore = -Infinity;
            
            // Debug first evaluation
            let evaluationCount = 0;
            
            for (const action of possibleActions) {
                const [xStr, rotStr] = action.split('_');
                const x = parseInt(xStr);
                const rotationIndex = parseInt(rotStr);
                
                // Simulate the move and evaluate the resulting board
                const testShape = getRotatedShape(pieceType, rotationIndex);
                const simulation = simulateLock(board, pieceType, testShape, x);
                
                if (!simulation) {
                    continue; // Invalid move
                }
                
                // Use the EXACT evaluation function from genetic algorithm!
                const features = computeBoardFeatures(simulation.board);
                
                // CRITICAL FIX: Use lines cleared from simulation, not from the cleared board!
                const linesCleared = simulation.cleared || 0;
                
                // Use the actual DEFAULT_WEIGHTS that work for GA
                let score = 0;
                score += features.aggregateHeight * -0.510066;  // Height penalty (negative is bad)
                score += linesCleared * 0.760666;               // Lines cleared (positive is good) - USE SIMULATION RESULT!
                score += features.holes * -0.35663;             // Holes penalty (negative is bad)
                score += features.bumpiness * -0.184483;        // Bumpiness penalty (negative is bad)
                
                // Scale up to make differences more pronounced
                score *= 100;
                
                // Bonus for clearing multiple lines (same as GA)
                if (linesCleared >= 2) {
                    score += linesCleared * 50;
                }
                
                // Small randomization to avoid identical play
                score += (Math.random() - 0.5) * 2;
                
                // Debug logging for first few evaluations
                if (evaluationCount < 3) {
                    console.log(`MC Heuristic eval #${evaluationCount}: action=${action}, score=${score.toFixed(2)}, height=${features.aggregateHeight}, holes=${features.holes}, linesCleared=${linesCleared}`);
                }
                evaluationCount++;
                
                if (score > bestScore) {
                    bestScore = score;
                    bestAction = action;
                }
            }
            
            return bestAction;
        }

        function getRotatedShape(pieceType, rotationIndex) {
            let shape = PIECES[pieceType];
            for (let i = 0; i < rotationIndex; i++) {
                shape = rotateShape(shape);
            }
            return shape;
        }
        
        function countIsolatedHoles(board) {
            // Count holes that are completely surrounded (hard to clear)
            let isolatedHoles = 0;
            for (let y = 1; y < BOARD_HEIGHT - 1; y++) {
                for (let x = 1; x < BOARD_WIDTH - 1; x++) {
                    if (!board[y][x] && 
                        board[y-1][x] && board[y+1][x] && 
                        board[y][x-1] && board[y][x+1]) {
                        isolatedHoles++;
                    }
                }
            }
            return isolatedHoles;
        }

        function calculateStateSimilarity(state1, state2) {
            // Ignore piece token when comparing similarity; only compare numeric feature buckets
            const toks1 = state1.split('_').filter(t => !t.startsWith('p'));
            const toks2 = state2.split('_').filter(t => !t.startsWith('p'));

            const features1 = toks1.map(f => parseInt(f.slice(1)));
            const features2 = toks2.map(f => parseInt(f.slice(1)));
            
            if (features1.length !== features2.length) return 0;
            
            let similarity = 0;
            for (let i = 0; i < features1.length; i++) {
                const diff = Math.abs(features1[i] - features2[i]);
                const maxDiff = i === 0 ? 10 : 5;  // Height has larger range
                similarity += Math.max(0, 1 - diff / maxDiff);
            }
            
            return similarity / features1.length;
        }

        function generateMarkovPossibleActions(board, pieceType) {
            // Generate all possible actions (similar to genetic algorithm)
            const baseShape = PIECES[pieceType];
            const possibleActions = [];
            
            // Try all rotations
            const rotations = [];
            rotations.push(baseShape);
            rotations.push(rotateShape(rotations[rotations.length - 1]));
            rotations.push(rotateShape(rotations[rotations.length - 1]));
            rotations.push(rotateShape(rotations[rotations.length - 1]));
            
            // Deduplicate rotations
            const uniqueRotations = [];
            const seen = new Set();
            for (let i = 0; i < 4; i++) {
                const key = JSON.stringify(rotations[i]);
                if (!seen.has(key)) {
                    seen.add(key);
                    uniqueRotations.push({ shape: rotations[i], rotationIndex: i });
                }
            }
            
            // Try each rotation at each valid position
            for (const rot of uniqueRotations) {
                for (let x = 0; x <= BOARD_WIDTH - rot.shape[0].length; x++) {
                    const sim = simulateLock(board, pieceType, rot.shape, x);
                    if (sim) {
                        possibleActions.push(actionToString(x, rot.rotationIndex));
                    }
                }
            }
            
            return possibleActions;
        }

        function parseActionString(action) {
            const [xStr, rStr] = action.split('_');
            return { x: parseInt(xStr), rotationIndex: parseInt(rStr) };
        }

        function evaluatePlacement(board, pieceType, action, weights) {
            const { x, rotationIndex } = parseActionString(action);
            const shape = getRotatedShape(pieceType, rotationIndex);
            const sim = simulateLock(board, pieceType, shape, x);
            if (!sim) return null;
            const f = computeBoardFeatures(sim.board);
            const score = (
                weights.completeLines * (sim.cleared || 0) +
                weights.aggregateHeight * f.aggregateHeight +
                weights.holes * f.holes +
                weights.bumpiness * f.bumpiness
            );
            return { board: sim.board, cleared: sim.cleared || 0, score };
        }

        function selectActionTwoPly(board, pieceType, nextPieceType, weights, possibleActions) {
            if (!possibleActions || possibleActions.length === 0) return null;
            const gamma = 0.9;
            let bestAction = null;
            let bestScore = -Infinity;
            for (const action of possibleActions) {
                const res1 = evaluatePlacement(board, pieceType, action, weights);
                if (!res1) continue;
                let secondBest = 0;
                if (nextPieceType) {
                    const nextActions = generateMarkovPossibleActions(res1.board, nextPieceType);
                    if (nextActions.length > 0) {
                        let bestSecond = -Infinity;
                        for (const a2 of nextActions) {
                            const res2 = evaluatePlacement(res1.board, nextPieceType, a2, weights);
                            if (res2 && res2.score > bestSecond) bestSecond = res2.score;
                        }
                        secondBest = bestSecond;
                    } else {
                        secondBest = 0;
                    }
                }
                const total = res1.score + gamma * secondBest;
                if (total > bestScore) {
                    bestScore = total;
                    bestAction = action;
                }
            }
            return bestAction;
        }

        function simulateLock(board, pieceType, shape, startX) {
            // Drop shape from top at given x until collision
            // Find initial y as the first collision above
            let x = startX;
            let y = 0;
            // Adjust x if out of bounds
            if (x < 0) x = 0;
            if (x + shape[0].length > BOARD_WIDTH) x = BOARD_WIDTH - shape[0].length;

            // If immediate collision at spawn, mark fail
            if (collidesShape(board, shape, x, y)) {
                return null;
            }
            while (!collidesShape(board, shape, x, y + 1)) {
                y++;
                if (y > BOARD_HEIGHT) break;
            }

            const newBoard = cloneBoard(board);
            for (let yy = 0; yy < shape.length; yy++) {
                for (let xx = 0; xx < shape[yy].length; xx++) {
                    if (shape[yy][xx]) {
                        const by = y + yy;
                        const bx = x + xx;
                        if (by >= 0 && by < BOARD_HEIGHT && bx >= 0 && bx < BOARD_WIDTH) {
                            newBoard[by][bx] = pieceType;
                        }
                    }
                }
            }

            // Clear lines
            let cleared = 0;
            for (let yy = BOARD_HEIGHT - 1; yy >= 0; yy--) {
                if (newBoard[yy].every(c => c !== null)) {
                    newBoard.splice(yy, 1);
                    newBoard.unshift(Array(BOARD_WIDTH).fill(null));
                    cleared++;
                    yy++;
                }
            }

            return { board: newBoard, cleared };
        }

        function collidesShape(board, shape, x, y) {
            for (let yy = 0; yy < shape.length; yy++) {
                for (let xx = 0; xx < shape[yy].length; xx++) {
                    if (shape[yy][xx]) {
                        const nx = x + xx;
                        const ny = y + yy;
                        if (nx < 0 || nx >= BOARD_WIDTH || ny >= BOARD_HEIGHT) return true;
                        if (ny >= 0 && board[ny][nx]) return true;
                    }
                }
            }
            return false;
        }

        function rotateShape(shape) {
            const rows = shape.length;
            const cols = shape[0].length;
            const rotated = [];
            for (let i = 0; i < cols; i++) {
                rotated[i] = [];
                for (let j = rows - 1; j >= 0; j--) {
                    rotated[i].push(shape[j][i]);
                }
            }
            return rotated;
        }

        class Piece {
            constructor(type) {
                this.type = type;
                this.shape = PIECES[type];
                this.x = Math.floor(BOARD_WIDTH / 2) - Math.floor(this.shape[0].length / 2);
                this.y = 0;
                this.rotation = 0;
            }

            rotate() {
                const rotated = [];
                const rows = this.shape.length;
                const cols = this.shape[0].length;
                
                for (let i = 0; i < cols; i++) {
                    rotated[i] = [];
                    for (let j = rows - 1; j >= 0; j--) {
                        rotated[i].push(this.shape[j][i]);
                    }
                }
                
                return rotated;
            }
        }

        class Player {
            constructor(id, isAI = false, aiType = 'genetic') {
                this.id = id;
                this.isAI = isAI;
                this.aiType = aiType; // 'genetic', 'markov', or 'mixed'
                this.board = Array(BOARD_HEIGHT).fill().map(() => Array(BOARD_WIDTH).fill(null));
                this.currentPiece = null;
                this.nextPiece = this.randomPiece();
                this.score = 0;
                this.lines = 0;
                this.level = 1;
                this.gameOver = false;
                this.powerUps = [];
                this.cooldowns = new Map();
                this.activeEffects = [];
                this.dropTime = 1000;
                this.lastDrop = Date.now();
                this.target = null;
                this.canvas = null;
                this.ctx = null;
                this.holdPiece = null;
                this.canHold = true;
                this.combo = 0;
                // AI planning/learning
                this.aiPlan = null; // { targetX, rotationIndex, performed: false }
                this.aiLastPlannedPieceId = 0;
                // GA genome assignment will set aiWeights when game starts
                this.aiWeights = null;
                this.aiFitness = 0; // accumulate score proxy (score + lines bonus)
                this.aiStepCooldown = 0; // spacing between actions (ms)
                // Markov chain AI properties
                this.markovChains = null;
                this.lastMarkovState = null;
                this.lastMarkovAction = null;
                this.lastMarkovScore = 0;
                this.lastMarkovLines = 0;
                this.lastFeaturesBefore = null;  // features snapshot before last chosen action
                this.markovInitialized = false; // Track when Markov fully takes over
                // Human tracking for Markov learning
                this.humanMoveHistory = [];
                this.lastHumanState = null;
                this.pieceCount = 0;
                // Benchmarking
                this.piecesPlaced = 0;        // counts completed placements
                this.benchmarkStartMs = 0;    // timestamp when counting starts
            }

            init(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                // Start PPS benchmark clock
                this.benchmarkStartMs = Date.now();
                this.spawnPiece();
            }

            randomPiece() {
                const types = Object.keys(PIECES);
                return types[Math.floor(Math.random() * types.length)];
            }

            spawnPiece() {
                this.currentPiece = new Piece(this.nextPiece);
                this.nextPiece = this.randomPiece();
                this.canHold = true;
                this.pieceCount++;
                
                if (this.collides(this.currentPiece)) {
                    this.gameOver = true;
                }
                // Invalidate AI plan on new piece
                this.aiPlan = null;
                
                // Track new piece for human learning (condition state on current piece)
                if (!this.isAI && MARKOV_DEFAULTS.learnFromHuman) {
                    this.lastHumanState = simplifyBoardToState(this.board, this.currentPiece.type, this.nextPiece);
                }
            }

            collides(piece, offsetX = 0, offsetY = 0) {
                for (let y = 0; y < piece.shape.length; y++) {
                    for (let x = 0; x < piece.shape[y].length; x++) {
                        if (piece.shape[y][x]) {
                            const newX = piece.x + x + offsetX;
                            const newY = piece.y + y + offsetY;
                            
                            if (newX < 0 || newX >= BOARD_WIDTH || newY >= BOARD_HEIGHT) {
                                return true;
                            }
                            
                            if (newY >= 0 && this.board[newY][newX]) {
                                return true;
                            }
                        }
                    }
                }
                return false;
            }

            move(dir) {
                if (!this.currentPiece || this.gameOver) return;
                
                if (!this.collides(this.currentPiece, dir, 0)) {
                    this.currentPiece.x += dir;
                }
            }

            rotate() {
                if (!this.currentPiece || this.gameOver) return;
                
                const oldShape = this.currentPiece.shape;
                this.currentPiece.shape = this.currentPiece.rotate();
                
                if (this.collides(this.currentPiece)) {
                    // Try wall kicks
                    const kicks = [0, -1, 1, -2, 2];
                    let valid = false;
                    
                    for (let kick of kicks) {
                        if (!this.collides(this.currentPiece, kick, 0)) {
                            this.currentPiece.x += kick;
                            valid = true;
                            break;
                        }
                    }
                    
                    if (!valid) {
                        this.currentPiece.shape = oldShape;
                    }
                }
                // Track human rotations for Markov learning
                if (!this.isAI && MARKOV_DEFAULTS.learnFromHuman) {
                    this.trackHumanMove();
                }
            }

            drop() {
                if (!this.currentPiece || this.gameOver) return false;
                
                if (!this.collides(this.currentPiece, 0, 1)) {
                    this.currentPiece.y++;
                    return true;
                } else {
                    this.lock();
                    return false;
                }
            }

            hardDrop() {
                if (!this.currentPiece || this.gameOver) return;
                
                // Record human's final placement for Markov learning
                if (!this.isAI && MARKOV_DEFAULTS.learnFromHuman) {
                    this.recordHumanPlacement();
                }
                
                let dropDistance = 0;
                while (!this.collides(this.currentPiece, 0, 1)) {
                    this.currentPiece.y++;
                    dropDistance++;
                }
                
                this.score += dropDistance * 2;
                this.lock();
            }

            lock() {
                const piece = this.currentPiece;
                
                for (let y = 0; y < piece.shape.length; y++) {
                    for (let x = 0; x < piece.shape[y].length; x++) {
                        if (piece.shape[y][x]) {
                            const boardY = piece.y + y;
                            const boardX = piece.x + x;
                            
                            if (boardY >= 0) {
                                this.board[boardY][boardX] = piece.type;
                            }
                        }
                    }
                }
                
                this.clearLines();
                // Count this completed placement for PPS benchmarking
                this.piecesPlaced++;
                this.spawnPiece();
            }

            clearLines() {
                let linesCleared = 0;
                
                for (let y = BOARD_HEIGHT - 1; y >= 0; y--) {
                    if (this.board[y].every(cell => cell !== null)) {
                        this.board.splice(y, 1);
                        this.board.unshift(Array(BOARD_WIDTH).fill(null));
                        linesCleared++;
                        y++; // Check the same row again
                        
                        // Visual effect
                        this.createLineEffect(y);
                    }
                }
                
                if (linesCleared > 0) {
                    this.lines += linesCleared;
                    this.combo++;
                    
                    // Scoring
                    const baseScore = [0, 100, 300, 500, 800][linesCleared] || 0;
                    this.score += baseScore * this.level * (1 + this.combo * 0.1);
                    
                    // Level up
                    this.level = Math.floor(this.lines / 10) + 1;
                    this.dropTime = Math.max(100, 1000 - (this.level - 1) * 100);
                    
                    // Power-up chance (only when enabled)
                    if (game && game.powerUpsEnabled && this.lines % 5 === 0) {
                        this.addRandomPowerUp();
                    }
                } else {
                    this.combo = 0;
                }
            }

            addRandomPowerUp() {
                if (!game || !game.powerUpsEnabled) return;
                if (this.powerUps.length >= 3) return;
                
                const types = IMPLEMENTED_POWERUPS;
                const type = types[Math.floor(Math.random() * types.length)];
                this.powerUps.push(type);
            }

            usePowerUp(index, targetId) {
                if (!game || !game.powerUpsEnabled) return;
                if (index >= this.powerUps.length) return;
                
                const powerUp = this.powerUps[index];
                const cooldownKey = powerUp;
                
                if (this.cooldowns.has(cooldownKey)) {
                    const remaining = this.cooldowns.get(cooldownKey) - Date.now();
                    if (remaining > 0) return;
                }
                
                this.powerUps.splice(index, 1);
                this.cooldowns.set(cooldownKey, Date.now() + 5000);
                
                // Apply power-up effect
                this.applyPowerUp(powerUp, targetId);
            }

            applyPowerUp(type, targetId) {
                if (!game || !game.powerUpsEnabled) return;
                const target = game.players.find(p => p.id === targetId);
                if (!target && POWERUPS[type].type === 'offensive') return;
                
                switch (type) {
                    case 'GARBAGE':
                        if (target) {
                            for (let i = 0; i < 3; i++) {
                                const garbageLine = Array(BOARD_WIDTH).fill('garbage');
                                const hole = Math.floor(Math.random() * BOARD_WIDTH);
                                garbageLine[hole] = null;
                                target.board.push(garbageLine);
                                target.board.shift();
                            }
                            this.showAttackEffect(target, 'GARBAGE!');
                        }
                        break;
                        
                    case 'SPEED':
                        if (target) {
                            target.dropTime = Math.max(50, target.dropTime / 2);
                            setTimeout(() => {
                                target.dropTime = Math.max(100, 1000 - (target.level - 1) * 100);
                            }, 15000);
                            this.showAttackEffect(target, 'SPEED!');
                        }
                        break;
                        
                    case 'BLIND':
                        if (target) {
                            target.activeEffects.push({ type: 'blind', endTime: Date.now() + 10000 });
                            this.showAttackEffect(target, 'BLIND!');
                        }
                        break;
                        
                    case 'SHIELD':
                        this.activeEffects.push({ type: 'shield', endTime: Date.now() + 30000 });
                        break;
                        
                    case 'CLEAR':
                        for (let i = 0; i < 3; i++) {
                            this.board.pop();
                            this.board.unshift(Array(BOARD_WIDTH).fill(null));
                        }
                        break;
                        
                    case 'SLOW':
                        this.dropTime = Math.min(2000, this.dropTime * 2);
                        setTimeout(() => {
                            this.dropTime = Math.max(100, 1000 - (this.level - 1) * 100);
                        }, 20000);
                        break;
                        
                    case 'ELIMINATE':
                        game.players.forEach(p => {
                            if (p.id !== this.id && !p.gameOver) {
                                // Add 3 rows of random garbage to target
                                for (let i = 0; i < 3; i++) {
                                    const stackLine = Array(BOARD_WIDTH).fill('garbage');
                                    // Create 2-3 random holes per line for fairness
                                    const numHoles = Math.floor(Math.random() * 2) + 2; // 2-3 holes
                                    for (let h = 0; h < numHoles; h++) {
                                        const hole = Math.floor(Math.random() * BOARD_WIDTH);
                                        stackLine[hole] = null;
                                    }
                                    p.board.push(stackLine);
                                    p.board.shift();
                                }
                                this.showAttackEffect(p, 'STACKED!');
                            }
                        });
                        break;
                }
            }

            createLineEffect(y) {
                // This would create visual effects for line clearing
                // Implementation would add DOM elements or canvas effects
            }

            showAttackEffect(target, text) {
                const indicator = document.createElement('div');
                indicator.className = 'attackIndicator';
                indicator.textContent = text;
                const section = document.querySelector(`#player${target.id}`);
                if (section) {
                    section.appendChild(indicator);
                    setTimeout(() => indicator.remove(), 1000);
                }
            }

            getGhostPiece() {
                if (!this.currentPiece) return null;
                
                const ghost = {
                    ...this.currentPiece,
                    y: this.currentPiece.y
                };
                
                while (!this.collides(ghost, 0, 1)) {
                    ghost.y++;
                }
                
                return ghost;
            }

            draw() {
                if (!this.ctx) return;
                
                // Clear canvas
                this.ctx.fillStyle = COLORS.EMPTY;
                this.ctx.fillRect(0, 0, BOARD_WIDTH * BLOCK_SIZE, BOARD_HEIGHT * BLOCK_SIZE);
                
                // Draw board
                for (let y = 0; y < BOARD_HEIGHT; y++) {
                    for (let x = 0; x < BOARD_WIDTH; x++) {
                        if (this.board[y][x]) {
                            this.ctx.fillStyle = this.board[y][x] === 'garbage' ? '#666' : COLORS[this.board[y][x]];
                            this.ctx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE - 1, BLOCK_SIZE - 1);
                        }
                    }
                }
                
                // Draw ghost piece
                const ghost = this.getGhostPiece();
                if (ghost && !this.activeEffects.some(e => e.type === 'blind')) {
                    this.ctx.fillStyle = COLORS.GHOST;
                    for (let y = 0; y < ghost.shape.length; y++) {
                        for (let x = 0; x < ghost.shape[y].length; x++) {
                            if (ghost.shape[y][x]) {
                                this.ctx.fillRect(
                                    (ghost.x + x) * BLOCK_SIZE,
                                    (ghost.y + y) * BLOCK_SIZE,
                                    BLOCK_SIZE - 1,
                                    BLOCK_SIZE - 1
                                );
                            }
                        }
                    }
                }
                
                // Draw current piece
                if (this.currentPiece) {
                    this.ctx.fillStyle = COLORS[this.currentPiece.type];
                    for (let y = 0; y < this.currentPiece.shape.length; y++) {
                        for (let x = 0; x < this.currentPiece.shape[y].length; x++) {
                            if (this.currentPiece.shape[y][x]) {
                                this.ctx.fillRect(
                                    (this.currentPiece.x + x) * BLOCK_SIZE,
                                    (this.currentPiece.y + y) * BLOCK_SIZE,
                                    BLOCK_SIZE - 1,
                                    BLOCK_SIZE - 1
                                );
                            }
                        }
                    }
                }
                
                // Draw grid lines
                this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                this.ctx.lineWidth = 0.5;
                for (let i = 0; i <= BOARD_WIDTH; i++) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(i * BLOCK_SIZE, 0);
                    this.ctx.lineTo(i * BLOCK_SIZE, BOARD_HEIGHT * BLOCK_SIZE);
                    this.ctx.stroke();
                }
                for (let i = 0; i <= BOARD_HEIGHT; i++) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, i * BLOCK_SIZE);
                    this.ctx.lineTo(BOARD_WIDTH * BLOCK_SIZE, i * BLOCK_SIZE);
                    this.ctx.stroke();
                }
                
                // Draw game over overlay
                if (this.gameOver) {
                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    this.ctx.fillRect(0, 0, BOARD_WIDTH * BLOCK_SIZE, BOARD_HEIGHT * BLOCK_SIZE);
                    this.ctx.fillStyle = '#fff';
                    this.ctx.font = 'bold 24px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText('GAME OVER', BOARD_WIDTH * BLOCK_SIZE / 2, BOARD_HEIGHT * BLOCK_SIZE / 2);
                }
            }

            update() {
                if (this.gameOver) return;
                
                const now = Date.now();
                
                // Auto drop
                if (now - this.lastDrop > this.dropTime) {
                    this.drop();
                    this.lastDrop = now;
                }
                
                // Update cooldowns
                for (let [key, time] of this.cooldowns) {
                    if (time < now) {
                        this.cooldowns.delete(key);
                    }
                }
                
                // Update effects
                this.activeEffects = this.activeEffects.filter(effect => effect.endTime > now);
                
                // AI logic: plan and execute steps
                if (this.isAI) {
                    if (!this.aiPlan) {
                        if (this.aiType === 'genetic' || (this.aiType === 'mixed' && Math.random() < 0.5)) {
                            this.aiPlan = this.planBestMove();
                        } else if (this.aiType === 'markov' || this.aiType === 'mixed') {
                            this.aiPlan = this.planMarkovMove();
                        }
                    }
                    this.executePlannedStep();
                }
            }

            aiMove() { /* legacy noop retained for compatibility */ }

            executePlannedStep() {
                if (!this.aiPlan || !this.currentPiece) return;
                const now = Date.now();
                if (!this._lastAIStep) this._lastAIStep = 0;
                
                // Consistent AI speed for all AI types - no level-based acceleration for fairness
                const stepDelay = 100; // Shared delay for GA and Markov
                
                if (now - this._lastAIStep < stepDelay) return;
                this._lastAIStep = now;

                // Apply rotation until target rotation reached
                const desiredRotations = this.aiPlan.rotationIndex;
                let currentRotations = 0;
                // Count how many 90-degree rotations from original shape would equal current shape
                // Instead, we can compare by trying to rotate from original
                // For simplicity: just rotate if not at desired count (approx)
                if (this._aiRotationProgress === undefined) this._aiRotationProgress = 0;
                if (this._aiRotationProgress < desiredRotations) {
                    this.rotate();
                    this._aiRotationProgress++;
                    return;
                }

                // Move horizontally toward targetX
                if (this.currentPiece.x < this.aiPlan.targetX) {
                    this.move(1);
                    return;
                }
                if (this.currentPiece.x > this.aiPlan.targetX) {
                    this.move(-1);
                    return;
                }

                // When aligned and rotated, hard drop
                this.hardDrop();
                this._aiRotationProgress = 0;
                this.aiPlan = null;

                // Occasionally use a power-up if available (only when enabled)
                if (game && game.powerUpsEnabled && this.powerUps.length > 0 && Math.random() < 0.15) {
                    const targets = game.players.filter(p => p.id !== this.id && !p.gameOver);
                    if (targets.length > 0) {
                        const target = targets[Math.floor(Math.random() * targets.length)];
                        this.usePowerUp(0, target.id);
                    }
                }
            }

            planBestMove() {
                if (!this.currentPiece) return null;
                const type = this.currentPiece.type;
                const baseShape = PIECES[type];
                const rotations = [];
                rotations.push(baseShape);
                rotations.push(rotateShape(rotations[rotations.length - 1]));
                rotations.push(rotateShape(rotations[rotations.length - 1]));
                rotations.push(rotateShape(rotations[rotations.length - 1]));

                // Deduplicate rotationally equivalent shapes by stringifying
                const uniqueRotations = [];
                const seen = new Set();
                for (let i = 0; i < 4; i++) {
                    const key = JSON.stringify(rotations[i]);
                    if (!seen.has(key)) {
                        seen.add(key);
                        uniqueRotations.push({ shape: rotations[i], rotationIndex: i });
                    }
                }

                let best = null;
                let bestScore = -Infinity;
                const board = this.board;
                const weights = this.aiWeights || loadAIWeights();

                for (const rot of uniqueRotations) {
                    const width = rot.shape[0].length;
                    for (let x = -2; x <= BOARD_WIDTH - 1; x++) { // generous scan window with bounds fix inside simulate
                        const sim = simulateLock(board, type, rot.shape, x);
                        if (!sim) continue;
                        
                        // Fix: Include lines cleared in the evaluation
                        const features = computeBoardFeatures(sim.board);
                        const score = (
                            weights.completeLines * (sim.cleared || 0) +  // Use actual lines cleared!
                            weights.aggregateHeight * features.aggregateHeight +
                            weights.holes * features.holes +
                            weights.bumpiness * features.bumpiness
                        );
                        
                        if (score > bestScore) {
                            bestScore = score;
                            best = { targetX: clampX(x, rot.shape), rotationIndex: rot.rotationIndex };
                        }
                    }
                }

                return best;
            }

            trackHumanMove() {
                // Track intermediate moves for pattern learning
                if (!this.currentPiece) return;
                
                const currentPos = {
                    x: this.currentPiece.x,
                    rotation: this.currentPiece.shape,
                    pieceType: this.currentPiece.type
                };
                
                this.humanMoveHistory.push(currentPos);
            }
            
            recordHumanPlacement() {
                // Record final placement decision by human player
                if (!this.currentPiece || !this.lastHumanState) return;
                
                // Check if this placement will result in line clears
                // Simulate the piece lock to see if lines will be cleared
                const testBoard = cloneBoard(this.board);
                const piece = this.currentPiece;
                
                // Place the piece on the test board
                for (let y = 0; y < piece.shape.length; y++) {
                    for (let x = 0; x < piece.shape[y].length; x++) {
                        if (piece.shape[y][x]) {
                            const boardY = piece.y + y;
                            const boardX = piece.x + x;
                            if (boardY >= 0 && boardY < BOARD_HEIGHT && boardX >= 0 && boardX < BOARD_WIDTH) {
                                testBoard[boardY][boardX] = piece.type;
                            }
                        }
                    }
                }
                
                // Count how many lines will be cleared
                let linesWillClear = 0;
                for (let y = 0; y < BOARD_HEIGHT; y++) {
                    if (testBoard[y].every(cell => cell !== null)) {
                        linesWillClear++;
                    }
                }
                
                // ONLY learn from moves that clear lines
                if (linesWillClear === 0) {
                    // Don't learn from non-line-clearing moves
                    this.humanMoveHistory = [];
                    return;
                }
                
                // Get shared Markov chains instance
                const globalChains = game ? game.markovChains : loadMarkovChains();
                if (!globalChains) return;
                
                // Determine the action taken (final position and rotation)
                const finalX = this.currentPiece.x;
                const rotationCount = this.humanMoveHistory.filter(m => 
                    m.pieceType === this.currentPiece.type
                ).length;
                
                // Simplified rotation index based on shape comparison
                let rotationIndex = 0;
                const baseShape = PIECES[this.currentPiece.type];
                let testShape = baseShape;
                for (let i = 0; i < 4; i++) {
                    if (JSON.stringify(testShape) === JSON.stringify(this.currentPiece.shape)) {
                        rotationIndex = i;
                        break;
                    }
                    testShape = rotateShape(testShape);
                }
                
                const action = actionToString(finalX, rotationIndex);
                const currentState = simplifyBoardToState(this.board, this.currentPiece.type, this.nextPiece);
                
                // Record in human patterns
                if (!globalChains.humanPatterns) {
                    globalChains.humanPatterns = new Map();
                }
                
                if (!globalChains.humanPatterns.has(this.lastHumanState)) {
                    globalChains.humanPatterns.set(this.lastHumanState, new Map());
                }
                
                const stateActions = globalChains.humanPatterns.get(this.lastHumanState);
                const count = stateActions.get(action) || 0;
                stateActions.set(action, count + 1);
                
                // Update transitions with weighted reward based on lines cleared
                // More lines = better reward to learn from
                const baseReward = linesWillClear * 1000;  // 1000 per line cleared
                const bonusForMultiLine = linesWillClear >= 2 ? linesWillClear * 500 : 0;  // Extra bonus for multi-line clears
                const reward = baseReward + bonusForMultiLine;
                
                console.log(`üìö Learning from human: ${linesWillClear} line(s) cleared, reward: ${reward}`);
                
                updateMarkovChain(
                    globalChains,
                    this.lastHumanState,
                    action,
                    currentState,
                    reward
                );
                
                // Clear history for next piece
                this.humanMoveHistory = [];
                globalChains.humanGamesObserved++;
                
                // Save the updated chains
                if (game) {
                    game.markovChains = globalChains;
                }
                saveMarkovChains(globalChains);
            }
            
            planMarkovMove() {
                if (!this.currentPiece) return null;
                
                // Initialize Markov chains if not already done
                if (!this.markovChains) {
                    this.markovChains = game ? game.markovChains : loadMarkovChains();
                }
                
                const currentState = simplifyBoardToState(this.board, this.currentPiece.type, this.nextPiece);
                const pieceType = this.currentPiece.type;
                const possibleActions = generateMarkovPossibleActions(this.board, pieceType);
                
                if (!possibleActions || possibleActions.length === 0) {
                    console.warn('No possible actions for Markov AI');
                    return null;
                }
                
                // Update chain with previous move if we have one
                if (this.lastMarkovState && this.lastMarkovAction) {
                    // Reward previous action using feature deltas (after previous lock vs before it)
                    const featuresAfter = computeBoardFeatures(this.board); // board after last lock
                    const featuresBefore = this.lastFeaturesBefore;          // snapshot taken before that lock
                    const fb = featuresBefore || featuresAfter;

                    // Improvements are positive when after < before for cost features
                    const deltaHeight = fb.aggregateHeight - featuresAfter.aggregateHeight; // positive is good
                    const deltaHoles = fb.holes - featuresAfter.holes;                      // positive is good
                    const deltaBump = fb.bumpiness - featuresAfter.bumpiness;               // positive is good
                    const linesCleared = this.lines - (this.lastMarkovLines || 0);

                    let reward = 0;
                    reward += linesCleared * 200;  // emphasize clears
                    reward += deltaHeight * 2;
                    reward += deltaBump * 1.5;
                    reward += deltaHoles * 50;
                    reward += 2; // small living bonus

                    updateMarkovChain(
                        this.markovChains,
                        this.lastMarkovState,
                        this.lastMarkovAction,
                        currentState,
                        reward
                    );
                }
                
                // Two-ply lookahead using known next piece; fallback to Markov prior if needed
                const selectedAction2Ply = selectActionTwoPly(this.board, pieceType, this.nextPiece, DEFAULT_WEIGHTS, possibleActions);
                const selectedAction = selectedAction2Ply || selectMarkovAction(this.markovChains, currentState, possibleActions, true, this.id, this.board, pieceType);
                const [targetXStr, rotationIndexStr] = selectedAction.split('_');
                const targetX = parseInt(targetXStr);
                const rotationIndex = parseInt(rotationIndexStr);
                
                // Store for next update
                this.lastMarkovState = currentState;
                this.lastMarkovAction = selectedAction;
                this.lastMarkovScore = this.score;
                this.lastMarkovLines = this.lines;
                // Snapshot features before executing the planned placement (used to compute deltas next tick)
                this.lastFeaturesBefore = computeBoardFeatures(this.board);
                
                return { targetX, rotationIndex };
            }
        }

        function clampX(x, shape) {
            if (x < 0) return 0;
            const maxX = BOARD_WIDTH - shape[0].length;
            if (x > maxX) return maxX;
            return x;
        }

        class Game {
            constructor(playerCount, aiType = 'genetic', powerUpsEnabled = true) {
                this.players = [];
                this.playerCount = playerCount;
                this.aiType = aiType;
                this.powerUpsEnabled = powerUpsEnabled;
                this.currentPlayer = 0;
                this.running = false;
                this.lastFrame = 0;
                // GA state
                this.gaState = loadAIWeights(); // { population, index, history }
                this.sessionAIResults = [];
                // Markov chains state - shared across all players for human learning
                this.markovChains = loadMarkovChains();
                // Optional GA population preview UI
                this.populationVis = null;
            }

            init() {
                // Create game container
                const container = document.getElementById('gameContainer');
                container.innerHTML = '';
                
                for (let i = 0; i < this.playerCount; i++) {
                    const versusMode = this.aiType === 'versus';
                    const isMain = (i === 0) && !versusMode;
                    const isAI = versusMode ? true : i > 0;
                    
                    // For mixed mode, alternate between genetic and markov
                    let playerAiType = this.aiType;
                    if (versusMode) {
                        const split = Math.floor(this.playerCount / 2);
                        playerAiType = (i < split) ? 'genetic' : 'markov';
                    } else if (this.aiType === 'mixed' && isAI) {
                        playerAiType = (i % 2 === 1) ? 'genetic' : 'markov';
                    }
                    
                    const player = new Player(i, isAI, playerAiType);
                    this.players.push(player);
                    
                    // Create player section
                    const section = document.createElement('div');
                    section.className = `playerSection ${isMain ? 'main' : ''}`;
                    section.id = `player${i}`;
                    
                    // Header
                    const header = document.createElement('div');
                    header.className = 'playerHeader';
                    let headerText = isMain ? 'YOU' : `CPU ${i}`;
                    if (!isMain) {
                        const aiTypeLabel = playerAiType === 'genetic' ? '(GA)' : '(MC)';
                        headerText += ` ${aiTypeLabel}`;
                    }
                    header.textContent = headerText;
                    section.appendChild(header);
                    
                    // Canvas
                    const canvas = document.createElement('canvas');
                    canvas.width = BOARD_WIDTH * BLOCK_SIZE;
                    canvas.height = BOARD_HEIGHT * BLOCK_SIZE;
                    // All players get same size canvas
                    canvas.className = '';
                    
                    const boardDiv = document.createElement('div');
                    boardDiv.className = 'gameBoard';
                    boardDiv.appendChild(canvas);
                    section.appendChild(boardDiv);
                    
                    // Stats
                    const stats = document.createElement('div');
                    stats.className = 'stats';
                    let statsHTML = `
                        <div><span>Score:</span> <span id="score${i}">0</span></div>
                        <div><span>Lines:</span> <span id="lines${i}">0</span></div>
                        <div><span>Level:</span> <span id="level${i}">1</span></div>
                    `;
                    if (isAI) {
                        statsHTML += `<div><span>PPS:</span> <span id="pps${i}">0.00</span></div>`;
                    }
                    stats.innerHTML = statsHTML;
                    section.appendChild(stats);
                    
                    // Power-ups UI (only for main player and only if enabled)
                    if (isMain && this.powerUpsEnabled) {
                        const powerUpsDiv = document.createElement('div');
                        powerUpsDiv.className = 'powerUpsContainer';
                        powerUpsDiv.id = 'powerUps';
                        section.appendChild(powerUpsDiv);
                        
                        // Target selector
                        const targetDiv = document.createElement('div');
                        targetDiv.className = 'targetSelector';
                        targetDiv.innerHTML = '<div>Target:</div>';
                        const targetButtons = document.createElement('div');
                        
                        for (let j = 1; j < this.playerCount; j++) {
                            const btn = document.createElement('button');
                            btn.className = 'targetButton';
                            btn.textContent = `CPU ${j}`;
                            btn.onclick = () => this.selectTarget(j);
                            if (j === 1) btn.classList.add('selected');
                            targetButtons.appendChild(btn);
                        }
                        
                        targetDiv.appendChild(targetButtons);
                        section.appendChild(targetDiv);
                    }
                    
                    container.appendChild(section);
                    player.init(canvas);

                    // Assign GA genomes to genetic AI players
                    if (isAI && (playerAiType === 'genetic' || playerAiType === 'mixed')) {
                        const genome = this.nextGenome();
                        player.aiWeights = genome.weights;
                        player._genomeId = genome.id;
                    }
                    
                    // Initialize Markov chains for Markov AI players
                    if (isAI && (playerAiType === 'markov' || playerAiType === 'mixed')) {
                        player.markovChains = this.markovChains || loadMarkovChains();
                    }
                }

                // In AI vs AI mode, render GA population preview with mini boards under the main boards
                if (this.aiType === 'versus') {
                    const containerEl = document.getElementById('gameContainer');
                    let panel = document.getElementById('populationPanel');
                    if (!panel) {
                        panel = document.createElement('div');
                        panel.id = 'populationPanel';
                        containerEl.appendChild(panel);
                    }
                    panel.innerHTML = '';
                    const header = document.createElement('div');
                    header.className = 'populationHeader';
                    header.innerHTML = `<span>üß¨ Genetic Population Preview</span><span style="font-weight:400;opacity:.8">(live)</span>`;
                    const grid = document.createElement('div');
                    grid.className = 'populationGrid';
                    panel.appendChild(header);
                    panel.appendChild(grid);

                    this.populationVis = new PopulationVisualizer(grid, this.gaState.population);
                }
                
                // Set initial target for human player only
                if (this.players.length > 1 && !this.players[0].isAI) {
                    this.players[0].target = 1;
                }
                
                this.running = true;
                this.setupControls();
                this.gameLoop();
            }

            nextGenome() {
                const pop = this.gaState.population;
                // Find first unevaluated genome to assign, else wrap around
                for (let i = 0; i < pop.length; i++) {
                    const g = pop[(this.gaState.index + i) % pop.length];
                    if (!g.assigned) {
                        g.assigned = true;
                        this.gaState.index = (this.gaState.index + i + 1) % pop.length;
                        saveAIWeights(this.gaState);
                        return g;
                    }
                }
                // If all assigned, just cycle
                const g = pop[this.gaState.index];
                this.gaState.index = (this.gaState.index + 1) % pop.length;
                saveAIWeights(this.gaState);
                return g;
            }

            selectTarget(targetId) {
                this.players[0].target = targetId;
                document.querySelectorAll('.targetButton').forEach((btn, i) => {
                    btn.classList.toggle('selected', i === targetId - 1);
                });
            }

            setupControls() {
                document.addEventListener('keydown', (e) => {
                    if (!this.running) return;
                    
                    const player = this.players[0];
                    if (player.gameOver) return;
                    
                    switch (e.key) {
                        case 'ArrowLeft':
                            e.preventDefault();
                            player.move(-1);
                            break;
                        case 'ArrowRight':
                            e.preventDefault();
                            player.move(1);
                            break;
                        case 'ArrowDown':
                            e.preventDefault();
                            player.drop();
                            player.score++;
                            break;
                        case 'ArrowUp':
                            e.preventDefault();
                            player.rotate();
                            break;
                        case ' ':
                            e.preventDefault();
                            player.hardDrop();
                            break;
                        case '1':
                        case '2':
                        case '3':
                            if (!this.powerUpsEnabled) break;
                            const index = parseInt(e.key) - 1;
                            if (player.powerUps[index]) {
                                player.usePowerUp(index, player.target);
                                this.updatePowerUps();
                            }
                            break;
                        case 'Tab':
                            if (!this.powerUpsEnabled) break;
                            e.preventDefault();
                            const targets = this.players.filter(p => p.id !== 0 && !p.gameOver);
                            if (targets.length > 0) {
                                const currentIndex = targets.findIndex(t => t.id === player.target);
                                const nextIndex = (currentIndex + 1) % targets.length;
                                this.selectTarget(targets[nextIndex].id);
                            }
                            break;
                    }
                });

                // Touch controls for mobile
                let touchStartX = null;
                let touchStartY = null;
                
                document.addEventListener('touchstart', (e) => {
                    touchStartX = e.touches[0].clientX;
                    touchStartY = e.touches[0].clientY;
                });
                
                document.addEventListener('touchmove', (e) => {
                    if (!touchStartX || !touchStartY) return;
                    
                    const touchEndX = e.touches[0].clientX;
                    const touchEndY = e.touches[0].clientY;
                    
                    const dx = touchEndX - touchStartX;
                    const dy = touchEndY - touchStartY;
                    
                    const player = this.players[0];
                    if (player.gameOver) return;
                    
                    if (Math.abs(dx) > Math.abs(dy)) {
                        if (dx > 50) {
                            player.move(1);
                            touchStartX = touchEndX;
                        } else if (dx < -50) {
                            player.move(-1);
                            touchStartX = touchEndX;
                        }
                    } else {
                        if (dy > 50) {
                            player.drop();
                            touchStartY = touchEndY;
                        }
                    }
                });
                
                document.addEventListener('touchend', (e) => {
                    const touchEndX = e.changedTouches[0].clientX;
                    const touchEndY = e.changedTouches[0].clientY;
                    
                    const dx = touchEndX - touchStartX;
                    const dy = touchEndY - touchStartY;
                    
                    if (Math.abs(dx) < 10 && Math.abs(dy) < 10) {
                        this.players[0].rotate();
                    }
                    
                    touchStartX = null;
                    touchStartY = null;
                });
            }

            updatePowerUps() {
                const container = document.getElementById('powerUps');
                if (!container) return;
                
                container.innerHTML = '';
                const player = this.players[0];
                
                player.powerUps.forEach((powerUp, index) => {
                    const div = document.createElement('div');
                    div.className = 'powerUp';
                    
                    const cooldownTime = player.cooldowns.get(powerUp);
                    if (cooldownTime && cooldownTime > Date.now()) {
                        div.classList.add('cooldown');
                        const remaining = Math.ceil((cooldownTime - Date.now()) / 1000);
                        div.innerHTML = `
                            <div class="cooldownTimer">${remaining}</div>
                        `;
                    } else {
                        div.innerHTML = `
                            <div class="icon">${POWERUPS[powerUp].icon}</div>
                            <div class="name">${POWERUPS[powerUp].name}</div>
                        `;
                        div.onclick = () => {
                            player.usePowerUp(index, player.target);
                            this.updatePowerUps();
                        };
                    }
                    
                    container.appendChild(div);
                });
            }

            updateStats() {
                this.players.forEach(player => {
                    const scoreEl = document.getElementById(`score${player.id}`);
                    const linesEl = document.getElementById(`lines${player.id}`);
                    const levelEl = document.getElementById(`level${player.id}`);
                    const ppsEl = document.getElementById(`pps${player.id}`);
                    
                    if (scoreEl) scoreEl.textContent = player.score;
                    if (linesEl) linesEl.textContent = player.lines;
                    if (levelEl) levelEl.textContent = player.level;
                    if (ppsEl && player.benchmarkStartMs) {
                        const elapsedSec = Math.max((Date.now() - player.benchmarkStartMs) / 1000, 0.001);
                        const pps = player.piecesPlaced / elapsedSec;
                        ppsEl.textContent = pps.toFixed(2);
                    }
                });
            }

            gameLoop(timestamp = 0) {
                if (!this.running) return;
                
                const deltaTime = timestamp - this.lastFrame;
                this.lastFrame = timestamp;
                
                // Update all players
                this.players.forEach(player => {
                    player.update();
                    player.draw();
                });
                
                // Update UI
                this.updateStats();
                if (this.powerUpsEnabled) this.updatePowerUps();
                if (this.populationVis) this.populationVis.update(timestamp, this.players);
                
                // Check for game over
                const alivePlayers = this.players.filter(p => !p.gameOver);
                if (alivePlayers.length <= 1 && this.playerCount > 1) {
                    this.endGame(alivePlayers[0]);
                } else if (alivePlayers.length === 0) {
                    this.endGame(null);
                } else {
                    requestAnimationFrame((t) => this.gameLoop(t));
                }
            }

            endGame(winner) {
                this.running = false;
                
                setTimeout(() => {
                    // Update GA fitness for assigned genomes
                    const aiPlayers = this.players.filter(p => p.isAI);
                    aiPlayers.forEach(p => {
                        const fitness = p.score + p.lines * 150; // emphasize lines
                        const genome = this.gaState.population.find(g => g.id === p._genomeId);
                        if (genome) {
                            genome.fitness = Math.max(genome.fitness || 0, fitness);
                            genome.evaluated = true;
                            genome.assigned = false;
                        }
                    });

                    // If all evaluated, evolve a new generation
                    if (this.gaState.population.every(g => g.evaluated)) {
                        this.evolvePopulation();
                    }
                    saveAIWeights(this.gaState);
                    const message = winner ? 
                        (winner.isAI ? `CPU ${winner.id} Wins!` : 'You Win!') : 
                        'Game Over!';
                    
                    if (confirm(`${message}\n\nPlay again?`)) {
                        location.reload();
                    }
                }, 1000);
            }

            evolvePopulation() {
                const pop = this.gaState.population.slice().sort((a, b) => b.fitness - a.fitness);
                // Elitism: keep top 2
                const next = [];
                const eliteCount = Math.min(2, pop.length);
                for (let i = 0; i < eliteCount; i++) {
                    next.push({ id: i, weights: { ...pop[i].weights }, fitness: 0, evaluated: false });
                }
                // Fill rest with offspring via tournament selection + crossover + mutation
                while (next.length < GA_DEFAULTS.populationSize) {
                    const parentA = tournamentSelect(pop);
                    const parentB = tournamentSelect(pop);
                    let childW = crossoverWeights(parentA.weights, parentB.weights);
                    childW = mutateWeights(childW, GA_DEFAULTS.mutationStrength);
                    next.push({ id: next.length, weights: childW, fitness: 0, evaluated: false });
                }
                this.gaState.population = next;
                this.gaState.index = 0;
                this.gaState.history.push({ ts: Date.now(), bestFitness: pop[0]?.fitness || 0 });
                if (this.populationVis) this.populationVis.rebuild(this.gaState.population);
            }
        }

        // --- Population Visualizer: render live mini transparent boards for GA ---
        function createEmptyBoard() {
            return Array.from({ length: BOARD_HEIGHT }, () => Array(BOARD_WIDTH).fill(null));
        }
        function randomPieceType() {
            const keys = Object.keys(PIECES);
            return keys[Math.floor(Math.random() * keys.length)];
        }

        class PopulationVisualizer {
            constructor(rootEl, population) {
                this.root = rootEl;
                this.population = population.slice();
                this.items = []; // { genome, canvas, ctx, sim, dead }
                this.lastStep = 0;
                this.intervalMs = 100; // Faster step rate for more responsive updates
                this.activeGenomes = new Map(); // Track active genome IDs -> player mapping
                this._build();
            }
            rebuild(newPopulation) {
                this.population = newPopulation.slice();
                // Reset all genomes to not dead when rebuilding (new generation)
                this.population.forEach(g => {
                    g.evaluated = false;
                    g.assigned = false;
                });
                this._build();
            }
            _build() {
                this.root.innerHTML = '';
                this.items = [];
                this.population.forEach(genome => {
                    const card = document.createElement('div');
                    card.className = 'miniCard';

                    const label = document.createElement('div');
                    label.className = 'miniLabel';
                    label.textContent = `Genome ${genome.id}`;
                    card.appendChild(label);

                    const canvas = document.createElement('canvas');
                    // Keep internal res small; CSS scales
                    canvas.width = BOARD_WIDTH * 10;
                    canvas.height = BOARD_HEIGHT * 10;
                    canvas.className = 'mini';
                    card.appendChild(canvas);

                    const stats = document.createElement('div');
                    stats.className = 'miniStats';
                    stats.textContent = 'lines 0 ¬∑ steps 0';
                    card.appendChild(stats);

                    this.root.appendChild(card);

                    this.items.push({
                        genome,
                        canvas,
                        ctx: canvas.getContext('2d'),
                        statsEl: stats,
                        card,
                        dead: false,
                        sim: {
                            board: createEmptyBoard(),
                            nextPiece: null,
                            steps: 0,
                            lines: 0
                        }
                    });
                });
            }
            update(ts, players = null) {
                // Update genome status from active players in real-time
                if (players) {
                    this._updateGenomeStatus(players);
                }
                
                if (!this.lastStep) this.lastStep = ts;
                const shouldStep = ts - this.lastStep >= this.intervalMs;
                if (shouldStep) this.lastStep = ts;
                
                this.items.forEach(it => {
                    // Skip dead genomes from simulation but still draw them
                    if (!it.dead && shouldStep) {
                        this._stepSim(it);
                    }
                    this._drawItem(it);
                    
                    // Update stats with real data if available
                    if (it.dead) {
                        it.statsEl.innerHTML = `<span style="color:#ff4444">ELIMINATED</span>`;
                    } else if (it.genome.evaluated) {
                        it.statsEl.innerHTML = `<span style="color:#44ff44">fitness ${it.genome.fitness || 0}</span>`;
                    } else {
                        it.statsEl.textContent = `lines ${it.sim.lines} ¬∑ steps ${it.sim.steps}`;
                    }
                });
            }
            
            _updateGenomeStatus(players) {
                // Track which genomes are actively playing
                const activePlayers = players.filter(p => p.isAI && p._genomeId !== undefined);
                
                this.items.forEach(item => {
                    const activePlayer = activePlayers.find(p => p._genomeId === item.genome.id);
                    
                    if (activePlayer) {
                        // Genome is actively playing
                        if (activePlayer.gameOver && !item.dead) {
                            // Just died - mark as dead immediately
                            item.dead = true;
                            item.card.classList.add('dead');
                            // Update the actual genome fitness immediately
                            item.genome.fitness = activePlayer.score + activePlayer.lines * 150;
                            item.genome.evaluated = true;
                        } else if (!activePlayer.gameOver) {
                            // Still playing - update live stats
                            item.sim.lines = activePlayer.lines;
                            item.sim.steps = activePlayer.piecesPlaced || 0;
                        }
                    } else if (item.genome.evaluated && !item.dead) {
                        // Mark as dead if genome has been evaluated (finished playing)
                        // Removed the item.genome.assigned check since it gets set to false
                        // after evaluation, which was preventing proper dead marking
                        item.dead = true;
                        item.card.classList.add('dead');
                    }
                });
            }
            _stepSim(item) {
                const { sim, genome } = item;
                // choose piece
                const pieceType = sim.nextPiece || randomPieceType();
                sim.nextPiece = randomPieceType();
                // generate possible actions (reuse helpers)
                const actions = generateMarkovPossibleActions(sim.board, pieceType);
                if (!actions || actions.length === 0) {
                    // If no moves, reset the board for this mini to keep animation going
                    item.sim.board = createEmptyBoard();
                    return;
                }
                // Score each action using genome weights
                let best = null;
                let bestScore = -Infinity;
                for (const a of actions) {
                    const res = evaluatePlacement(sim.board, pieceType, a, genome.weights);
                    if (!res) continue;
                    if (res.score > bestScore) {
                        bestScore = res.score;
                        best = { action: a, cleared: res.cleared };
                    }
                }
                if (!best) return;
                const { x, rotationIndex } = parseActionString(best.action);
                const shape = getRotatedShape(pieceType, rotationIndex);
                const applied = simulateLock(sim.board, pieceType, shape, x);
                if (applied) {
                    sim.board = applied.board;
                    sim.lines += applied.cleared || 0;
                }
                sim.steps++;
            }
            _drawItem(item) {
                const { ctx, canvas, sim, dead } = item;
                const w = canvas.width;
                const h = canvas.height;
                const bs = Math.floor(w / BOARD_WIDTH);
                // Clear and set background based on status
                ctx.clearRect(0, 0, w, h);
                if (dead) {
                    ctx.fillStyle = 'rgba(100,0,0,0.3)'; // Red tint for dead genomes
                } else {
                    ctx.fillStyle = 'rgba(0,0,0,0.25)';
                }
                ctx.fillRect(0, 0, w, h);
                // Grid fade
                ctx.strokeStyle = 'rgba(255,255,255,0.06)';
                ctx.lineWidth = 1;
                for (let x = 0; x <= BOARD_WIDTH; x++) {
                    ctx.beginPath();
                    ctx.moveTo(x * bs + 0.5, 0);
                    ctx.lineTo(x * bs + 0.5, h);
                    ctx.stroke();
                }
                for (let y = 0; y <= BOARD_HEIGHT; y++) {
                    ctx.beginPath();
                    ctx.moveTo(0, y * bs + 0.5);
                    ctx.lineTo(w, y * bs + 0.5);
                    ctx.stroke();
                }
                // Draw blocks
                for (let y = 0; y < BOARD_HEIGHT; y++) {
                    for (let x = 0; x < BOARD_WIDTH; x++) {
                        const cell = sim.board[y][x];
                        if (!cell) continue;
                        ctx.fillStyle = cell === 'garbage' ? 'rgba(160,160,160,0.9)' : COLORS[cell] || '#999';
                        ctx.fillRect(x * bs + 1, y * bs + 1, bs - 2, bs - 2);
                    }
                }
            }
        }

        // Global game instance
        let game = null;

        function startGame(playerCount, aiType = 'genetic') {
            try {
                console.log('Starting game with', playerCount, 'players, AI type:', aiType);
                document.getElementById('startMenu').style.display = 'none';
                document.getElementById('gameContainer').style.display = 'flex';
                // Hide controls in AI-vs-AI mode
                document.querySelector('.controls').style.display = (aiType === 'versus') ? 'none' : 'block';
                
                const powerUpsEnabled = document.getElementById('togglePowerUps') ? document.getElementById('togglePowerUps').checked : true;
                game = new Game(playerCount, aiType, powerUpsEnabled);
                game.init();
            } catch (error) {
                console.error('Error starting game:', error);
                alert('Error starting game: ' + error.message);
                // Reset UI on error
                document.getElementById('startMenu').style.display = 'flex';
                document.getElementById('gameContainer').style.display = 'none';
                document.querySelector('.controls').style.display = 'none';
            }
        }
    </script>
</body>
</html>
