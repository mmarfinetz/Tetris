<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tetris AI Evolution Lab - Watch Learning Happen!</title>
    <!--
    ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    üß¨ TETRIS AI EVOLUTION LAB - VISUALIZATION FEATURES üß¨
    ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    üéÆ GAME MODES:
    ‚Ä¢ Battle Genetic AI - Play against evolved AI
    ‚Ä¢ Battle Markov AI - Play against learning AI
    ‚Ä¢ Watch Bots Battle - 4 AI vs AI arena with live evolution
    ‚Ä¢ Compare Generations - Time travel to compare AI across generations

    üìä LIVE VISUALIZATIONS:
    ‚Ä¢ Real-time population mini-boards with fitness badges (Elite/Avg/New/Low)
    ‚Ä¢ Decision-making heatmap showing AI "thoughts" on main boards
    ‚Ä¢ Currently playing genomes pulse with cyan glow
    ‚Ä¢ Death animations when genomes are eliminated
    ‚Ä¢ Color-coded cards: Green=Elite, Blue=Average, Red=Low fitness

    üß¨ GA DASHBOARD (ga_visualization.html):
    ‚Ä¢ Live generation ticker and metrics
    ‚Ä¢ Real-time best/avg fitness evolution chart
    ‚Ä¢ Diversity tracking with exploration indicators
    ‚Ä¢ Dynamic top 10 genome bars with badges
    ‚Ä¢ Updates every 500ms from localStorage

    üî¨ TRAINING LAB (Press 'T' during game):
    ‚Ä¢ Automated training with speed controls (1x/5x/MAX)
    ‚Ä¢ Real-time metrics: Generation, Best, Avg, Diversity
    ‚Ä¢ Sparkline chart showing fitness progression
    ‚Ä¢ Training progress indicator
    ‚Ä¢ Minimizable overlay interface

    üïê GENERATION TIME TRAVEL:
    ‚Ä¢ Select any two generations to compare
    ‚Ä¢ Watch side-by-side battles
    ‚Ä¢ See evolution progress visually

    üé® COLOR SEMANTICS:
    ‚Ä¢ Green ‚Üí Performance / Fitness / Elite
    ‚Ä¢ Blue ‚Üí Strategy / Average performers
    ‚Ä¢ Yellow/Orange ‚Üí Exploration / Diversity / New
    ‚Ä¢ Red ‚Üí Low performance / Elimination
    ‚Ä¢ Cyan ‚Üí Currently active/playing

    üí° KEYBOARD SHORTCUTS:
    ‚Ä¢ 'T' - Toggle Training Lab overlay
    ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    -->
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            /* Allow vertical scrolling so the population panel can sit below */
            overflow-x: hidden;
            overflow-y: auto;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }

        #gameContainer {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            padding: 20px;
            max-width: 1400px;
            width: 100%;
            justify-content: center;
        }

        .playerSection {
            background: rgba(0, 0, 0, 0.7);
            border-radius: 15px;
            padding: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            position: relative;
        }

        .playerSection.main {
            order: 2;
            /* All players same size */
        }

        .playerHeader {
            text-align: center;
            margin-bottom: 10px;
            padding: 10px;
            background: linear-gradient(90deg, #f093fb 0%, #f5576c 100%);
            border-radius: 10px;
            font-weight: bold;
            font-size: 18px;
        }

        .gameBoard {
            position: relative;
            border: 3px solid #fff;
            border-radius: 5px;
            background: rgba(0, 0, 0, 0.9);
            display: inline-block;
        }

        /* All players get same size canvases now */

        canvas {
            display: block;
            image-rendering: pixelated;
            width: 200px;
            height: 400px;
        }

        .stats {
            margin-top: 10px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            font-size: 14px;
        }

        .stats div {
            margin: 5px 0;
            display: flex;
            justify-content: space-between;
        }

        .powerUpsContainer {
            margin-top: 15px;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
        }

        .powerUp {
            width: 60px;
            height: 60px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: 2px solid #fff;
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }

        .powerUp:hover {
            transform: scale(1.1);
            box-shadow: 0 5px 20px rgba(255, 255, 255, 0.3);
        }

        .powerUp.active {
            animation: pulse 1s infinite;
        }

        .powerUp.cooldown {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .powerUp .icon {
            font-size: 24px;
            margin-bottom: 2px;
        }

        .powerUp .name {
            font-size: 9px;
            text-align: center;
        }

        .powerUp .cooldownTimer {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 20px;
            font-weight: bold;
            color: #ff0;
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(255, 255, 255, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(255, 255, 255, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 255, 255, 0); }
        }

        #startMenu {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .menuTitle {
            font-size: 48px;
            margin-bottom: 30px;
            background: linear-gradient(90deg, #f093fb 0%, #f5576c 100%);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-align: center;
        }

        .menuButtons {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .menuButton {
            padding: 15px 40px;
            font-size: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            color: white;
            border-radius: 30px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .menuButton:hover {
            transform: scale(1.05);
            box-shadow: 0 10px 30px rgba(102, 126, 234, 0.5);
        }

        .controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            z-index: 100;
        }

        .controls h3 {
            margin-bottom: 10px;
        }

        .controlsGrid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            font-size: 12px;
        }

        .effect {
            position: absolute;
            pointer-events: none;
            z-index: 500;
        }

        .lineCleared {
            position: absolute;
            background: linear-gradient(90deg, transparent, #fff, transparent);
            height: 20px;
            width: 100%;
            animation: lineClear 0.5s ease-out;
        }

        @keyframes lineClear {
            0% { 
                transform: scaleX(0);
                opacity: 1;
            }
            100% { 
                transform: scaleX(1);
                opacity: 0;
            }
        }

        .attackIndicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 30px;
            color: #ff0;
            font-weight: bold;
            animation: attackPulse 1s ease-out;
            pointer-events: none;
            z-index: 600;
        }

        @keyframes attackPulse {
            0% {
                transform: translate(-50%, -50%) scale(0);
                opacity: 1;
            }
            50% {
                transform: translate(-50%, -50%) scale(1.5);
            }
            100% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 0;
            }
        }

        .targetSelector {
            margin-top: 10px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
        }

        .targetButton {
            padding: 5px 10px;
            margin: 5px;
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid #fff;
            color: white;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .targetButton.selected {
            background: rgba(255, 100, 100, 0.5);
            transform: scale(1.1);
        }

        @media (max-width: 768px) {
            #gameContainer {
                flex-direction: column;
                align-items: center;
            }
            
            .playerSection.main {
                transform: scale(1);
            }
            
            canvas {
                width: 100%;
                max-width: 200px;
                height: auto;
            }
            
            .controls {
                width: 90%;
                font-size: 10px;
            }
        }

        /* Population preview panel (mini transparent boards) */
        #populationPanel {
            flex-basis: 100%;
            max-width: 1400px;
            width: 100%;
            margin-top: 8px;
            background: rgba(0, 0, 0, 0.35);
            border-radius: 12px;
            padding: 12px 12px 16px 12px;
            box-shadow: 0 6px 24px rgba(0,0,0,0.35);
        }
        .populationHeader {
            font-weight: 700;
            font-size: 16px;
            opacity: 0.9;
            margin: 2px 0 10px 2px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .populationGrid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 10px;
        }

        /* LocalTrainer Overlay Styles */
        .trainer-overlay {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 400px;
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid rgba(102, 126, 234, 0.6);
            border-radius: 15px;
            padding: 20px;
            z-index: 1000;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.8);
            font-family: 'Segoe UI', sans-serif;
        }

        .trainer-overlay.minimized {
            width: 200px;
            height: 60px;
            overflow: hidden;
        }

        .trainer-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }

        .trainer-title {
            font-size: 18px;
            font-weight: bold;
            color: #667eea;
        }

        .trainer-controls {
            display: flex;
            gap: 8px;
        }

        .trainer-btn {
            padding: 6px 12px;
            border: none;
            border-radius: 6px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
        }

        .trainer-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        .trainer-btn.danger {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
        }

        .trainer-btn.success {
            background: linear-gradient(135deg, #4ade80 0%, #22c55e 100%);
        }

        .trainer-stats {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin: 15px 0;
        }

        .stat-card {
            background: rgba(255, 255, 255, 0.05);
            padding: 10px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .stat-label {
            font-size: 11px;
            opacity: 0.7;
            margin-bottom: 4px;
        }

        .stat-value {
            font-size: 20px;
            font-weight: bold;
            color: #4ade80;
        }

        .stat-value.blue {
            color: #60a5fa;
        }

        .stat-value.yellow {
            color: #f59e0b;
        }

        .trainer-chart {
            width: 100%;
            height: 120px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            margin: 10px 0;
        }

        .speed-controls {
            display: flex;
            gap: 8px;
            margin: 10px 0;
        }

        .speed-btn {
            flex: 1;
            padding: 8px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.05);
            color: white;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.2s;
        }

        .speed-btn.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-color: #667eea;
        }

        .progress-text {
            font-size: 12px;
            opacity: 0.8;
            margin: 8px 0;
            text-align: center;
        }

        .miniCard {
            background: rgba(255,255,255,0.06);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 10px;
            padding: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }
        .miniCard:hover { 
            transform: translateY(-2px);
            box-shadow: 0 6px 18px rgba(0,0,0,0.3);
        }
        .miniCard.dead {
            border-color: rgba(255,50,50,0.4);
            opacity: 0.6;
            background: rgba(40,10,10,0.3);
            animation: deathPulse 0.5s ease-out;
        }
        @keyframes deathPulse {
            0% { background: rgba(255,50,50,0.6); transform: scale(1.05); }
            100% { background: rgba(40,10,10,0.3); transform: scale(1); }
        }
        .miniCard.playing {
            box-shadow: 0 0 18px rgba(0, 255, 255, 0.7);
            transform: translateY(-3px);
            border-color: rgba(0, 255, 255, 0.8);
            animation: playingPulse 1.5s infinite;
        }
        @keyframes playingPulse {
            0%, 100% { box-shadow: 0 0 18px rgba(0, 255, 255, 0.7); }
            50% { box-shadow: 0 0 25px rgba(0, 255, 255, 0.9); }
        }
        .miniCard.elite {
            border-color: rgba(74, 222, 128, 0.6);
            background: rgba(74, 222, 128, 0.08);
        }
        .miniCard.avg {
            border-color: rgba(96, 165, 250, 0.5);
            background: rgba(96, 165, 250, 0.06);
        }
        .miniCard.low {
            border-color: rgba(239, 68, 68, 0.4);
            background: rgba(239, 68, 68, 0.04);
        }
        .miniLabel {
            font-size: 11px;
            opacity: 0.9;
            margin-bottom: 6px;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .miniStats {
            font-size: 10px;
            opacity: 0.8;
            margin-top: 6px;
        }
        .genomeBadge {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 8px;
            font-size: 8px;
            font-weight: bold;
        }
        .genomeBadge.elite {
            background: linear-gradient(135deg, #4ade80 0%, #22c55e 100%);
            color: #000;
        }
        .genomeBadge.avg {
            background: linear-gradient(135deg, #60a5fa 0%, #3b82f6 100%);
            color: #000;
        }
        .genomeBadge.new {
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
            color: #000;
        }
        .genomeBadge.low {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
            color: #fff;
        }
        canvas.mini {
            display: block;
            image-rendering: pixelated;
            width: 100px;
            height: 200px;
            opacity: 0.85;
            border-radius: 6px;
            border: 1px solid rgba(255,255,255,0.25);
            background: radial-gradient(120px 240px at 50% 50%, rgba(255,255,255,0.06), rgba(0,0,0,0.25));
        }
    </style>
</head>
<body>
    <div id="startMenu">
        <h1 class="menuTitle">TETRIS BATTLE</h1>
        <div class="menuButtons">
            <button class="menuButton" onclick="startGame(2, 'genetic')">Battle Genetic AI Bot</button>
            <button class="menuButton" onclick="startGame(2, 'markov')">Battle Markov AI Bot</button>
            <button class="menuButton" onclick="startGame(4, 'versus')">Watch Bots Battle</button>
            <button class="menuButton" onclick="showCompareGenerations()" style="background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);">üïê Compare Generations</button>
        </div>
        <div style="margin-top: 16px; font-size: 16px; display: flex; align-items: center; gap: 8px;">
            <input id="togglePowerUps" type="checkbox" checked style="transform: scale(1.2);" />
            <label for="togglePowerUps">Enable Power-ups</label>
        </div>
        <div style="margin-top: 12px; font-size: 14px; opacity: 0.7; text-align: center;">
            Press <span style="color: #667eea; font-weight: bold;">T</span> during game for Training Lab
        </div>
    </div>

    <div id="compareModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 2000; justify-content: center; align-items: center;">
        <div style="background: rgba(30,30,50,0.95); border: 2px solid rgba(102,126,234,0.6); border-radius: 20px; padding: 40px; max-width: 500px;">
            <h2 style="margin-bottom: 20px; color: #f59e0b;">üïê Generation Time Travel</h2>
            <p style="margin-bottom: 20px; opacity: 0.9;">Compare AI performance across generations. Watch how your bots evolved!</p>

            <div style="margin-bottom: 20px;">
                <label style="display: block; margin-bottom: 8px; font-size: 14px;">Generation A:</label>
                <select id="genA" style="width: 100%; padding: 10px; border-radius: 8px; background: rgba(0,0,0,0.5); border: 1px solid rgba(255,255,255,0.3); color: white; font-size: 16px;">
                    <option>Loading...</option>
                </select>
            </div>

            <div style="margin-bottom: 30px;">
                <label style="display: block; margin-bottom: 8px; font-size: 14px;">Generation B:</label>
                <select id="genB" style="width: 100%; padding: 10px; border-radius: 8px; background: rgba(0,0,0,0.5); border: 1px solid rgba(255,255,255,0.3); color: white; font-size: 16px;">
                    <option>Loading...</option>
                </select>
            </div>

            <div style="display: flex; gap: 10px; justify-content: center;">
                <button class="menuButton" onclick="startGenerationComparison()" style="flex: 1;">Start Comparison</button>
                <button class="menuButton" onclick="closeCompareModal()" style="flex: 1; background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);">Cancel</button>
            </div>
        </div>
    </div>

    <div id="gameContainer" style="display: none;">
        <!-- Player sections will be generated dynamically -->
    </div>

    <div class="controls" style="display: none;">
        <h3>Controls</h3>
        <div class="controlsGrid">
            <div>‚¨ÖÔ∏è‚û°Ô∏è Move</div>
            <div>‚¨áÔ∏è Soft Drop</div>
            <div>‚¨ÜÔ∏è Rotate</div>
            <div>Space: Hard Drop</div>
            <div>1-5: Power-ups</div>
            <div>Tab: Change Target</div>
            <div>Esc: Menu</div>
        </div>
        <button class="menuButton" onclick="returnToMenu()" style="margin-top: 15px; padding: 10px 25px; font-size: 16px;">Back to Menu</button>
    </div>

    <button id="backToMenuBtn" onclick="returnToMenu()" style="display: none; position: fixed; top: 20px; right: 20px; z-index: 100; padding: 10px 20px; font-size: 14px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border: none; color: white; border-radius: 20px; cursor: pointer;">Back to Menu</button>

    <script>
        // Game Constants
        const BOARD_WIDTH = 10;
        const BOARD_HEIGHT = 20;
        const BLOCK_SIZE = 20;
        const COLORS = {
            I: '#00f0f0',
            O: '#f0f000',
            T: '#a000f0',
            S: '#00f000',
            Z: '#f00000',
            J: '#0000f0',
            L: '#f0a000',
            EMPTY: '#000',
            GHOST: 'rgba(255, 255, 255, 0.2)'
        };

        // Tetromino definitions
        const PIECES = {
            I: [[1,1,1,1]],
            O: [[1,1],[1,1]],
            T: [[0,1,0],[1,1,1]],
            S: [[0,1,1],[1,1,0]],
            Z: [[1,1,0],[0,1,1]],
            J: [[1,0,0],[1,1,1]],
            L: [[0,0,1],[1,1,1]]
        };

        // Power-up definitions
        const POWERUPS = {
            GARBAGE: { name: 'Garbage', icon: 'üóëÔ∏è', type: 'offensive' },
            SPEED: { name: 'Speed', icon: '‚ö°', type: 'offensive' },
            BLIND: { name: 'Blind', icon: 'üëÅÔ∏è', type: 'offensive' },
            SCRAMBLE: { name: 'Scramble', icon: 'üîÄ', type: 'offensive' },
            GRAVITY: { name: 'Gravity', icon: 'üîÑ', type: 'offensive' },
            SHIELD: { name: 'Shield', icon: 'üõ°Ô∏è', type: 'defensive' },
            CLEAR: { name: 'Clear', icon: 'üí£', type: 'defensive' },
            SLOW: { name: 'Slow', icon: 'üêå', type: 'defensive' },
            GHOST: { name: 'Ghost', icon: 'üëª', type: 'defensive' },
            FREEZE: { name: 'Freeze', icon: '‚ùÑÔ∏è', type: 'defensive' },
            STEAL: { name: 'Steal', icon: 'üéØ', type: 'special' },
            MIRROR: { name: 'Mirror', icon: 'ü™û', type: 'special' },
            ELIMINATE: { name: 'Stack', icon: 'üìö', type: 'offensive' }
        };
        // Only these power-ups have concrete effects implemented below
        const IMPLEMENTED_POWERUPS = ['GARBAGE','SPEED','BLIND','SHIELD','CLEAR','SLOW','ELIMINATE'];

        // -------- Simple Learning AI (Heuristic + Evolution) --------
        const AI_STORAGE_KEY = 'tetris_ai_weights_v2_population';
        
        // -------- Markov Chain AI --------
        const MARKOV_STORAGE_KEY = 'tetris_markov_chains_v2_human_learned';
        const MARKOV_DEFAULTS = {
            stateHistorySize: 1000,    // How many state transitions to remember
            minObservations: 3,        // Minimum observations before using chain (lowered since learning from expert)
            humanMimicRate: 0.3,       // How often to follow learned human patterns vs exploring (lowered since no initial data)
            explorationRate: 0.1,      // Chance to make exploratory move (reduced since heuristics are now good)
            stateSimplification: 'features', // 'features' or 'positions'
            learnFromHuman: true       // Whether to learn from human player
        };
        const DEFAULT_WEIGHTS = {
            // Lower is better for these costs
            aggregateHeight: -0.510066,
            completeLines: 0.760666,
            holes: -0.35663,
            bumpiness: -0.184483
        };

        const GA_DEFAULTS = {
            populationSize: 50,
            tournamentSize: 3,
            mutationRate: 0.15,
            mutationStrength: 0.15,
            crossoverRate: 0.7,
            immigrationRate: 0.05,  // 5% chance per generation to add random genome
            immigrationCount: 2     // Number of random genomes to inject
        };

        function loadAIWeights() {
            try {
                const saved = localStorage.getItem(AI_STORAGE_KEY);
                if (!saved) return { population: seedPopulation(), index: 0, history: [] };
                const parsed = JSON.parse(saved);
                if (!parsed.population) return { population: seedPopulation(), index: 0, history: [] };
                // Reset evaluation status for new game session
                parsed.population.forEach(genome => {
                    genome.evaluated = false;
                    genome.assigned = false;
                });
                return parsed;
            } catch (_) {
                return { population: seedPopulation(), index: 0, history: [] };
            }
        }

        function saveAIWeights(state) {
            try {
                localStorage.setItem(AI_STORAGE_KEY, JSON.stringify(state));
            } catch (_) {}
        }

        function mutateWeights(base, strength = GA_DEFAULTS.mutationStrength) {
            const mutated = { ...base };
            Object.keys(mutated).forEach(k => {
                if (Math.random() < GA_DEFAULTS.mutationRate) {
                    const delta = (Math.random() * 2 - 1) * strength * Math.max(1, Math.abs(mutated[k]));
                    mutated[k] += delta;
                }
            });
            return mutated;
        }

        function seedPopulation() {
            const pop = [];
            for (let i = 0; i < GA_DEFAULTS.populationSize; i++) {
                pop.push({ id: i, weights: mutateWeights({ ...DEFAULT_WEIGHTS }, 0.2), fitness: 0, evaluated: false });
            }
            return pop;
        }

        function tournamentSelect(population, k = GA_DEFAULTS.tournamentSize) {
            let best = null;
            for (let i = 0; i < k; i++) {
                const ind = population[Math.floor(Math.random() * population.length)];
                if (!best || ind.fitness > best.fitness) best = ind;
            }
            return best;
        }

        function crossoverWeights(a, b) {
            if (Math.random() > GA_DEFAULTS.crossoverRate) return { ...a };
            const child = {};
            const keys = Object.keys(a);
            const pivot = Math.floor(Math.random() * keys.length);
            keys.forEach((k, idx) => {
                child[k] = idx < pivot ? a[k] : b[k];
            });
            return child;
        }

        function evaluateBoardHeuristic(board) {
            return evaluateBoardHeuristicWith(board, DEFAULT_WEIGHTS);
        }

        function evaluateBoardHeuristicWith(board, w) {
            const h = computeBoardFeatures(board);
            // Higher score is better
            return (
                w.completeLines * h.completeLines +
                w.aggregateHeight * h.aggregateHeight +
                w.holes * h.holes +
                w.bumpiness * h.bumpiness
            );
        }

        function computeBoardFeatures(board) {
            let aggregateHeight = 0;
            let holes = 0;
            let bumpiness = 0;
            let completeLines = 0;

            const heights = new Array(BOARD_WIDTH).fill(0);

            for (let y = 0; y < BOARD_HEIGHT; y++) {
                let filled = true;
                for (let x = 0; x < BOARD_WIDTH; x++) {
                    if (!board[y][x]) filled = false;
                }
                if (filled) completeLines++;
            }

            for (let x = 0; x < BOARD_WIDTH; x++) {
                let y;
                for (y = 0; y < BOARD_HEIGHT; y++) {
                    if (board[y][x]) break;
                }
                heights[x] = BOARD_HEIGHT - y;
                aggregateHeight += heights[x];

                // Count holes below first block
                let blockSeen = false;
                for (let yy = 0; yy < BOARD_HEIGHT; yy++) {
                    if (board[yy][x]) blockSeen = true;
                    else if (blockSeen) holes++;
                }
            }

            for (let x = 0; x < BOARD_WIDTH - 1; x++) {
                bumpiness += Math.abs(heights[x] - heights[x + 1]);
            }

            return { aggregateHeight, holes, bumpiness, completeLines };
        }

        function cloneBoard(board) {
            return board.map(row => row.slice());
        }

        // -------- Markov Chain AI Implementation --------
        function loadMarkovChains() {
            try {
                const saved = localStorage.getItem(MARKOV_STORAGE_KEY);
                if (!saved) return initializeMarkovChains();
                
                const parsed = JSON.parse(saved);
                if (!parsed || !parsed.chains) return initializeMarkovChains();
                
                // Reconstruct Maps from saved data
                const chains = {
                    stateTransitions: new Map(),
                    stateHistory: parsed.chains.stateHistory || [],
                    totalObservations: parsed.chains.totalObservations || 0,
                    humanPatterns: new Map(),
                    humanGamesObserved: parsed.chains.humanGamesObserved || 0
                };
                
                // Restore stateTransitions Map if it exists
                if (parsed.chains.stateTransitions) {
                    for (const [state, actions] of Object.entries(parsed.chains.stateTransitions)) {
                        chains.stateTransitions.set(state, new Map(Object.entries(actions)));
                    }
                }
                
                // Restore humanPatterns Map if it exists
                if (parsed.chains.humanPatterns) {
                    for (const [state, actions] of Object.entries(parsed.chains.humanPatterns)) {
                        chains.humanPatterns.set(state, new Map(Object.entries(actions)));
                    }
                }
                
                return chains;
            } catch (e) {
                console.error('Error loading Markov chains:', e);
                return initializeMarkovChains();
            }
        }

        function saveMarkovChains(chains) {
            try {
                // Convert Maps to objects for JSON serialization
                const serializable = {
                    stateTransitions: {},
                    stateHistory: chains.stateHistory || [],
                    totalObservations: chains.totalObservations || 0,
                    humanPatterns: {},
                    humanGamesObserved: chains.humanGamesObserved || 0
                };
                
                // Convert stateTransitions Map to object
                if (chains.stateTransitions) {
                    for (const [state, actionMap] of chains.stateTransitions.entries()) {
                        serializable.stateTransitions[state] = {};
                        for (const [action, data] of actionMap.entries()) {
                            serializable.stateTransitions[state][action] = data;
                        }
                    }
                }
                
                // Convert humanPatterns Map to object
                if (chains.humanPatterns) {
                    for (const [state, actionMap] of chains.humanPatterns.entries()) {
                        serializable.humanPatterns[state] = {};
                        for (const [action, count] of actionMap.entries()) {
                            serializable.humanPatterns[state][action] = count;
                        }
                    }
                }
                
                localStorage.setItem(MARKOV_STORAGE_KEY, JSON.stringify({
                    chains: serializable,
                    lastUpdated: Date.now()
                }));
            } catch (e) {
                console.error('Error saving Markov chains:', e);
            }
        }

        function initializeMarkovChains() {
            return {
                stateTransitions: new Map(),    // Map of state -> Map of actions -> probability
                stateHistory: [],               // Recent state-action pairs
                totalObservations: 0,
                humanPatterns: new Map(),       // Map of state -> Map of actions -> count (from human player)
                humanGamesObserved: 0          // Number of games learned from human
            };
        }

        function simplifyBoardToState(board, pieceType = null, nextPieceType = null) {
            // Convert board to a simplified state representation
            const features = computeBoardFeatures(board);
            
            // Discretize features into ranges for state representation
            const heightCategory = Math.floor(features.aggregateHeight / 20); // 0-19, 20-39, etc.
            const holeCategory = Math.min(features.holes, 10); // 0-10+ holes
            const bumpCategory = Math.floor(features.bumpiness / 5); // 0-4, 5-9, etc.
            const lineCategory = features.completeLines; // 0, 1, 2, 3, 4 (usually 0 before drop)
            
            // Include current piece type in the key if provided to disambiguate actions across pieces
            const piecePrefix = pieceType ? `p${pieceType}_` : '';
            const nextPrefix = nextPieceType ? `n${nextPieceType}_` : '';
            return `${piecePrefix}${nextPrefix}h${heightCategory}_o${holeCategory}_b${bumpCategory}_l${lineCategory}`;
        }

        function actionToString(targetX, rotationIndex) {
            return `${targetX}_${rotationIndex}`;
        }

        function updateMarkovChain(chains, prevState, action, currentState, reward) {
            if (!chains.stateTransitions.has(prevState)) {
                chains.stateTransitions.set(prevState, new Map());
            }
            
            const actionMap = chains.stateTransitions.get(prevState);
            if (!actionMap.has(action)) {
                actionMap.set(action, { count: 0, totalReward: 0 });
            }
            
            const actionData = actionMap.get(action);
            actionData.count++;
            actionData.totalReward += reward;
            chains.totalObservations++;
            
            // Keep history limited
            chains.stateHistory.push({ prevState, action, currentState, reward });
            if (chains.stateHistory.length > MARKOV_DEFAULTS.stateHistorySize) {
                chains.stateHistory.shift();
            }
            
            saveMarkovChains(chains);
        }

        function selectMarkovAction(chains, currentState, possibleActions, useHumanPatterns = true, playerId = null, board = null, pieceType = null) {
            // Validate inputs
            if (!board || !pieceType) {
                console.warn(`Markov AI: Missing critical data - board: ${!!board}, pieceType: ${pieceType}`);
            }
            
            // Exploration: sometimes make random moves to discover new patterns
            if (Math.random() < MARKOV_DEFAULTS.explorationRate) {
                return selectActionWithBasicHeuristics(possibleActions, board, pieceType);
            }
            
            // Use human-learned patterns if available and we want to mimic them
            if (useHumanPatterns && chains.humanPatterns && chains.humanPatterns.size > 0 && 
                Math.random() < MARKOV_DEFAULTS.humanMimicRate) {
                const humanAction = selectHumanLearnedAction(chains, currentState, possibleActions);
                if (humanAction) return humanAction;
            }
            
            // Check if we have data for this state
            if (!chains.stateTransitions.has(currentState)) {
                // If no data, try similar states or use basic heuristics
                return selectFromSimilarStates(chains, currentState, possibleActions, board, pieceType);
            }
            
            const actionMap = chains.stateTransitions.get(currentState);
            let bestAction = null;
            let bestScore = -Infinity;
            let foundLearnedAction = false;
            
            // Score each possible action based on historical performance
            for (const action of possibleActions) {
                if (actionMap.has(action) && actionMap.get(action).count >= MARKOV_DEFAULTS.minObservations) {
                    const data = actionMap.get(action);
                    const avgReward = data.totalReward / data.count;
                    const confidence = Math.min(data.count / 20, 1); // Confidence based on observations
                    const score = avgReward * confidence;
                    
                    if (score > bestScore) {
                        bestScore = score;
                        bestAction = action;
                        foundLearnedAction = true;
                    }
                }
            }
            
            // Check if we found a learned action and should celebrate
            if (foundLearnedAction && bestAction && playerId !== null) {
                const player = game && game.players ? game.players.find(p => p.id === playerId) : null;
                if (player && !player.markovInitialized) {
                    const totalStates = chains.stateTransitions.size;
                    const totalObservations = chains.totalObservations;
                    console.log(`üß† CPU ${playerId} (MC): Markov initialized, it's on motherfucker! üöÄ`);
                    console.log(`   üìä Stats: ${totalStates} states learned, ${totalObservations} total observations`);
                    player.markovInitialized = true;
                }
            }
            
            // If no good historical data, use smart fallback
            return bestAction || selectFromSimilarStates(chains, currentState, possibleActions, board, pieceType);
        }

        function selectHumanLearnedAction(chains, currentState, possibleActions) {
            // Prioritize actions that humans have taken in similar situations
            if (!chains.humanPatterns) return null;
            
            const statePattern = chains.humanPatterns.get(currentState);
            if (statePattern) {
                // Return the most common human action for this state
                let bestAction = null;
                let bestCount = 0;
                for (const [action, count] of statePattern.entries()) {
                    if (possibleActions.includes(action) && count > bestCount) {
                        bestCount = count;
                        bestAction = action;
                    }
                }
                return bestAction;
            }
            return null;
        }

        function selectFromSimilarStates(chains, currentState, possibleActions, board = null, pieceType = null) {
            // Find similar states and use their best actions
            const stateFeatures = currentState.split('_');
            let bestAction = null;
            let bestScore = -Infinity;
            
            // Look for states with similar characteristics
            for (const [state, actionMap] of chains.stateTransitions.entries()) {
                const similarity = calculateStateSimilarity(currentState, state);
                if (similarity > 0.7) {  // 70% similarity threshold
                    for (const action of possibleActions) {
                        if (actionMap.has(action)) {
                            const data = actionMap.get(action);
                            const avgReward = data.totalReward / data.count;
                            const score = avgReward * similarity;
                            if (score > bestScore) {
                                bestScore = score;
                                bestAction = action;
                            }
                        }
                    }
                }
            }
            
            // Better fallback: use smart heuristics with board evaluation
            if (!bestAction && possibleActions.length > 0) {
                bestAction = selectActionWithBasicHeuristics(possibleActions, board, pieceType);
            }
            return bestAction;
        }

        function selectActionWithBasicHeuristics(possibleActions, board = null, pieceType = null) {
            // Use REAL Tetris strategy when no learned data exists
            if (!board || !pieceType || possibleActions.length === 0) {
                console.error('CRITICAL: Markov Chain AI missing data!', {
                    hasBoard: !!board,
                    pieceType: pieceType,
                    actionsCount: possibleActions.length,
                    actions: possibleActions.slice(0, 5)
                });
                // Better fallback: prefer center positions and minimal rotations
                const centerActions = possibleActions.filter(a => {
                    const [x, r] = a.split('_').map(Number);
                    return x >= 3 && x <= 6 && r <= 1;
                });
                if (centerActions.length > 0) {
                    return centerActions[0];
                }
                return possibleActions[0] || '4_0'; // Default to center with no rotation
            }
            
            let bestAction = possibleActions[0];
            let bestScore = -Infinity;
            
            // Debug first evaluation
            let evaluationCount = 0;
            
            for (const action of possibleActions) {
                const [xStr, rotStr] = action.split('_');
                const x = parseInt(xStr);
                const rotationIndex = parseInt(rotStr);
                
                // Simulate the move and evaluate the resulting board
                const testShape = getRotatedShape(pieceType, rotationIndex);
                const simulation = simulateLock(board, pieceType, testShape, x);
                
                if (!simulation) {
                    continue; // Invalid move
                }
                
                // Use the EXACT evaluation function from genetic algorithm!
                const features = computeBoardFeatures(simulation.board);
                
                // CRITICAL FIX: Use lines cleared from simulation, not from the cleared board!
                const linesCleared = simulation.cleared || 0;
                
                // Use the actual DEFAULT_WEIGHTS that work for GA
                let score = 0;
                score += features.aggregateHeight * -0.510066;  // Height penalty (negative is bad)
                score += linesCleared * 0.760666;               // Lines cleared (positive is good) - USE SIMULATION RESULT!
                score += features.holes * -0.35663;             // Holes penalty (negative is bad)
                score += features.bumpiness * -0.184483;        // Bumpiness penalty (negative is bad)
                
                // Scale up to make differences more pronounced
                score *= 100;
                
                // Bonus for clearing multiple lines (same as GA)
                if (linesCleared >= 2) {
                    score += linesCleared * 50;
                }
                
                // Small randomization to avoid identical play
                score += (Math.random() - 0.5) * 2;
                
                // Debug logging for first few evaluations
                if (evaluationCount < 3) {
                    console.log(`MC Heuristic eval #${evaluationCount}: action=${action}, score=${score.toFixed(2)}, height=${features.aggregateHeight}, holes=${features.holes}, linesCleared=${linesCleared}`);
                }
                evaluationCount++;
                
                if (score > bestScore) {
                    bestScore = score;
                    bestAction = action;
                }
            }
            
            return bestAction;
        }

        function getRotatedShape(pieceType, rotationIndex) {
            let shape = PIECES[pieceType];
            for (let i = 0; i < rotationIndex; i++) {
                shape = rotateShape(shape);
            }
            return shape;
        }
        
        function countIsolatedHoles(board) {
            // Count holes that are completely surrounded (hard to clear)
            let isolatedHoles = 0;
            for (let y = 1; y < BOARD_HEIGHT - 1; y++) {
                for (let x = 1; x < BOARD_WIDTH - 1; x++) {
                    if (!board[y][x] && 
                        board[y-1][x] && board[y+1][x] && 
                        board[y][x-1] && board[y][x+1]) {
                        isolatedHoles++;
                    }
                }
            }
            return isolatedHoles;
        }

        function calculateStateSimilarity(state1, state2) {
            // Ignore piece token when comparing similarity; only compare numeric feature buckets
            const toks1 = state1.split('_').filter(t => !t.startsWith('p'));
            const toks2 = state2.split('_').filter(t => !t.startsWith('p'));

            const features1 = toks1.map(f => parseInt(f.slice(1)));
            const features2 = toks2.map(f => parseInt(f.slice(1)));
            
            if (features1.length !== features2.length) return 0;
            
            let similarity = 0;
            for (let i = 0; i < features1.length; i++) {
                const diff = Math.abs(features1[i] - features2[i]);
                const maxDiff = i === 0 ? 10 : 5;  // Height has larger range
                similarity += Math.max(0, 1 - diff / maxDiff);
            }
            
            return similarity / features1.length;
        }

        function generateMarkovPossibleActions(board, pieceType) {
            // Generate all possible actions (similar to genetic algorithm)
            const baseShape = PIECES[pieceType];
            const possibleActions = [];
            
            // Try all rotations
            const rotations = [];
            rotations.push(baseShape);
            rotations.push(rotateShape(rotations[rotations.length - 1]));
            rotations.push(rotateShape(rotations[rotations.length - 1]));
            rotations.push(rotateShape(rotations[rotations.length - 1]));
            
            // Deduplicate rotations
            const uniqueRotations = [];
            const seen = new Set();
            for (let i = 0; i < 4; i++) {
                const key = JSON.stringify(rotations[i]);
                if (!seen.has(key)) {
                    seen.add(key);
                    uniqueRotations.push({ shape: rotations[i], rotationIndex: i });
                }
            }
            
            // Try each rotation at each valid position
            for (const rot of uniqueRotations) {
                for (let x = 0; x <= BOARD_WIDTH - rot.shape[0].length; x++) {
                    const sim = simulateLock(board, pieceType, rot.shape, x);
                    if (sim) {
                        possibleActions.push(actionToString(x, rot.rotationIndex));
                    }
                }
            }
            
            return possibleActions;
        }

        function parseActionString(action) {
            const [xStr, rStr] = action.split('_');
            return { x: parseInt(xStr), rotationIndex: parseInt(rStr) };
        }

        function evaluatePlacement(board, pieceType, action, weights) {
            const { x, rotationIndex } = parseActionString(action);
            const shape = getRotatedShape(pieceType, rotationIndex);
            const sim = simulateLock(board, pieceType, shape, x);
            if (!sim) return null;
            const f = computeBoardFeatures(sim.board);
            const score = (
                weights.completeLines * (sim.cleared || 0) +
                weights.aggregateHeight * f.aggregateHeight +
                weights.holes * f.holes +
                weights.bumpiness * f.bumpiness
            );
            return { board: sim.board, cleared: sim.cleared || 0, score };
        }

        function selectActionTwoPly(board, pieceType, nextPieceType, weights, possibleActions) {
            if (!possibleActions || possibleActions.length === 0) return null;
            const gamma = 0.9;
            let bestAction = null;
            let bestScore = -Infinity;
            for (const action of possibleActions) {
                const res1 = evaluatePlacement(board, pieceType, action, weights);
                if (!res1) continue;
                let secondBest = 0;
                if (nextPieceType) {
                    const nextActions = generateMarkovPossibleActions(res1.board, nextPieceType);
                    if (nextActions.length > 0) {
                        let bestSecond = -Infinity;
                        for (const a2 of nextActions) {
                            const res2 = evaluatePlacement(res1.board, nextPieceType, a2, weights);
                            if (res2 && res2.score > bestSecond) bestSecond = res2.score;
                        }
                        secondBest = bestSecond;
                    } else {
                        secondBest = 0;
                    }
                }
                const total = res1.score + gamma * secondBest;
                if (total > bestScore) {
                    bestScore = total;
                    bestAction = action;
                }
            }
            return bestAction;
        }

        function simulateLock(board, pieceType, shape, startX) {
            // Drop shape from top at given x until collision
            // Find initial y as the first collision above
            let x = startX;
            let y = 0;
            // Adjust x if out of bounds
            if (x < 0) x = 0;
            if (x + shape[0].length > BOARD_WIDTH) x = BOARD_WIDTH - shape[0].length;

            // If immediate collision at spawn, mark fail
            if (collidesShape(board, shape, x, y)) {
                return null;
            }
            while (!collidesShape(board, shape, x, y + 1)) {
                y++;
                if (y > BOARD_HEIGHT) break;
            }

            const newBoard = cloneBoard(board);
            for (let yy = 0; yy < shape.length; yy++) {
                for (let xx = 0; xx < shape[yy].length; xx++) {
                    if (shape[yy][xx]) {
                        const by = y + yy;
                        const bx = x + xx;
                        if (by >= 0 && by < BOARD_HEIGHT && bx >= 0 && bx < BOARD_WIDTH) {
                            newBoard[by][bx] = pieceType;
                        }
                    }
                }
            }

            // Clear lines
            let cleared = 0;
            for (let yy = BOARD_HEIGHT - 1; yy >= 0; yy--) {
                if (newBoard[yy].every(c => c !== null)) {
                    newBoard.splice(yy, 1);
                    newBoard.unshift(Array(BOARD_WIDTH).fill(null));
                    cleared++;
                    yy++;
                }
            }

            return { board: newBoard, cleared };
        }

        function collidesShape(board, shape, x, y) {
            for (let yy = 0; yy < shape.length; yy++) {
                for (let xx = 0; xx < shape[yy].length; xx++) {
                    if (shape[yy][xx]) {
                        const nx = x + xx;
                        const ny = y + yy;
                        if (nx < 0 || nx >= BOARD_WIDTH || ny >= BOARD_HEIGHT) return true;
                        if (ny >= 0 && board[ny][nx]) return true;
                    }
                }
            }
            return false;
        }

        function rotateShape(shape) {
            const rows = shape.length;
            const cols = shape[0].length;
            const rotated = [];
            for (let i = 0; i < cols; i++) {
                rotated[i] = [];
                for (let j = rows - 1; j >= 0; j--) {
                    rotated[i].push(shape[j][i]);
                }
            }
            return rotated;
        }

        class Piece {
            constructor(type) {
                this.type = type;
                this.shape = PIECES[type];
                this.x = Math.floor(BOARD_WIDTH / 2) - Math.floor(this.shape[0].length / 2);
                this.y = 0;
                this.rotation = 0;
            }

            rotate() {
                const rotated = [];
                const rows = this.shape.length;
                const cols = this.shape[0].length;
                
                for (let i = 0; i < cols; i++) {
                    rotated[i] = [];
                    for (let j = rows - 1; j >= 0; j--) {
                        rotated[i].push(this.shape[j][i]);
                    }
                }
                
                return rotated;
            }
        }

        class Player {
            constructor(id, isAI = false, aiType = 'genetic') {
                this.id = id;
                this.isAI = isAI;
                this.aiType = aiType; // 'genetic', 'markov', or 'mixed'
                this.board = Array(BOARD_HEIGHT).fill().map(() => Array(BOARD_WIDTH).fill(null));
                this.currentPiece = null;
                this.nextPiece = this.randomPiece();
                this.score = 0;
                this.lines = 0;
                this.level = 1;
                this.gameOver = false;
                this.powerUps = [];
                this.cooldowns = new Map();
                this.activeEffects = [];
                this.dropTime = 1000;
                this.lastDrop = Date.now();
                this.target = null;
                this.canvas = null;
                this.ctx = null;
                this.holdPiece = null;
                this.canHold = true;
                this.combo = 0;
                // AI planning/learning
                this.aiPlan = null; // { targetX, rotationIndex, performed: false }
                this.aiLastPlannedPieceId = 0;
                // GA genome assignment will set aiWeights when game starts
                this.aiWeights = null;
                this.aiFitness = 0; // accumulate score proxy (score + lines bonus)
                this.aiStepCooldown = 0; // spacing between actions (ms)
                // Markov chain AI properties
                this.markovChains = null;
                this.lastMarkovState = null;
                this.lastMarkovAction = null;
                this.lastMarkovScore = 0;
                this.lastMarkovLines = 0;
                this.lastFeaturesBefore = null;  // features snapshot before last chosen action
                this.markovInitialized = false; // Track when Markov fully takes over
                // Human tracking for Markov learning
                this.humanMoveHistory = [];
                this.lastHumanState = null;
                this.pieceCount = 0;
                // Benchmarking
                this.piecesPlaced = 0;        // counts completed placements
                this.benchmarkStartMs = 0;    // timestamp when counting starts
            }

            init(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                // Start PPS benchmark clock
                this.benchmarkStartMs = Date.now();
                this.spawnPiece();
            }

            randomPiece() {
                const types = Object.keys(PIECES);
                return types[Math.floor(Math.random() * types.length)];
            }

            spawnPiece() {
                this.currentPiece = new Piece(this.nextPiece);
                this.nextPiece = this.randomPiece();
                this.canHold = true;
                this.pieceCount++;
                
                if (this.collides(this.currentPiece)) {
                    this.gameOver = true;
                }
                // Invalidate AI plan on new piece
                this.aiPlan = null;
                
                // Track new piece for human learning (condition state on current piece)
                if (!this.isAI && MARKOV_DEFAULTS.learnFromHuman) {
                    this.lastHumanState = simplifyBoardToState(this.board, this.currentPiece.type, this.nextPiece);
                }
            }

            collides(piece, offsetX = 0, offsetY = 0) {
                for (let y = 0; y < piece.shape.length; y++) {
                    for (let x = 0; x < piece.shape[y].length; x++) {
                        if (piece.shape[y][x]) {
                            const newX = piece.x + x + offsetX;
                            const newY = piece.y + y + offsetY;
                            
                            if (newX < 0 || newX >= BOARD_WIDTH || newY >= BOARD_HEIGHT) {
                                return true;
                            }
                            
                            if (newY >= 0 && this.board[newY][newX]) {
                                return true;
                            }
                        }
                    }
                }
                return false;
            }

            move(dir) {
                if (!this.currentPiece || this.gameOver) return;
                
                if (!this.collides(this.currentPiece, dir, 0)) {
                    this.currentPiece.x += dir;
                }
            }

            rotate() {
                if (!this.currentPiece || this.gameOver) return;
                
                const oldShape = this.currentPiece.shape;
                this.currentPiece.shape = this.currentPiece.rotate();
                
                if (this.collides(this.currentPiece)) {
                    // Try wall kicks
                    const kicks = [0, -1, 1, -2, 2];
                    let valid = false;
                    
                    for (let kick of kicks) {
                        if (!this.collides(this.currentPiece, kick, 0)) {
                            this.currentPiece.x += kick;
                            valid = true;
                            break;
                        }
                    }
                    
                    if (!valid) {
                        this.currentPiece.shape = oldShape;
                    }
                }
                // Track human rotations for Markov learning
                if (!this.isAI && MARKOV_DEFAULTS.learnFromHuman) {
                    this.trackHumanMove();
                }
            }

            drop() {
                if (!this.currentPiece || this.gameOver) return false;
                
                if (!this.collides(this.currentPiece, 0, 1)) {
                    this.currentPiece.y++;
                    return true;
                } else {
                    this.lock();
                    return false;
                }
            }

            hardDrop() {
                if (!this.currentPiece || this.gameOver) return;
                
                // Record human's final placement for Markov learning
                if (!this.isAI && MARKOV_DEFAULTS.learnFromHuman) {
                    this.recordHumanPlacement();
                }
                
                let dropDistance = 0;
                while (!this.collides(this.currentPiece, 0, 1)) {
                    this.currentPiece.y++;
                    dropDistance++;
                }
                
                this.score += dropDistance * 2;
                this.lock();
            }

            lock() {
                const piece = this.currentPiece;
                
                for (let y = 0; y < piece.shape.length; y++) {
                    for (let x = 0; x < piece.shape[y].length; x++) {
                        if (piece.shape[y][x]) {
                            const boardY = piece.y + y;
                            const boardX = piece.x + x;
                            
                            if (boardY >= 0) {
                                this.board[boardY][boardX] = piece.type;
                            }
                        }
                    }
                }
                
                this.clearLines();
                // Count this completed placement for PPS benchmarking
                this.piecesPlaced++;
                this.spawnPiece();
            }

            clearLines() {
                let linesCleared = 0;
                
                for (let y = BOARD_HEIGHT - 1; y >= 0; y--) {
                    if (this.board[y].every(cell => cell !== null)) {
                        this.board.splice(y, 1);
                        this.board.unshift(Array(BOARD_WIDTH).fill(null));
                        linesCleared++;
                        y++; // Check the same row again
                        
                        // Visual effect
                        this.createLineEffect(y);
                    }
                }
                
                if (linesCleared > 0) {
                    this.lines += linesCleared;
                    this.combo++;
                    
                    // Scoring
                    const baseScore = [0, 100, 300, 500, 800][linesCleared] || 0;
                    this.score += baseScore * this.level * (1 + this.combo * 0.1);
                    
                    // Level up
                    this.level = Math.floor(this.lines / 10) + 1;
                    this.dropTime = Math.max(100, 1000 - (this.level - 1) * 100);
                    
                    // Power-up chance (only when enabled)
                    if (game && game.powerUpsEnabled && this.lines % 5 === 0) {
                        this.addRandomPowerUp();
                    }
                } else {
                    this.combo = 0;
                }
            }

            addRandomPowerUp() {
                if (!game || !game.powerUpsEnabled) return;
                if (this.powerUps.length >= 3) return;
                
                const types = IMPLEMENTED_POWERUPS;
                const type = types[Math.floor(Math.random() * types.length)];
                this.powerUps.push(type);
            }

            usePowerUp(index, targetId) {
                if (!game || !game.powerUpsEnabled) return;
                if (index >= this.powerUps.length) return;
                
                const powerUp = this.powerUps[index];
                const cooldownKey = powerUp;
                
                if (this.cooldowns.has(cooldownKey)) {
                    const remaining = this.cooldowns.get(cooldownKey) - Date.now();
                    if (remaining > 0) return;
                }
                
                this.powerUps.splice(index, 1);
                this.cooldowns.set(cooldownKey, Date.now() + 5000);
                
                // Apply power-up effect
                this.applyPowerUp(powerUp, targetId);
            }

            applyPowerUp(type, targetId) {
                if (!game || !game.powerUpsEnabled) return;
                const target = game.players.find(p => p.id === targetId);
                if (!target && POWERUPS[type].type === 'offensive') return;
                
                switch (type) {
                    case 'GARBAGE':
                        if (target) {
                            // Add garbage lines properly by pushing existing pieces up
                            for (let i = 0; i < 3; i++) {
                                const garbageLine = Array(BOARD_WIDTH).fill('garbage');
                                const hole = Math.floor(Math.random() * BOARD_WIDTH);
                                garbageLine[hole] = null;
                                
                                // Remove top row and add garbage at bottom
                                // This pushes all pieces up
                                target.board.shift();
                                target.board.push(garbageLine);
                                
                                // Check if pieces reached the top (game over condition)
                                if (target.board[0].some(cell => cell !== null)) {
                                    target.gameOver = true;
                                }
                            }
                            this.showAttackEffect(target, 'GARBAGE!');
                        }
                        break;
                        
                    case 'SPEED':
                        if (target) {
                            target.dropTime = Math.max(50, target.dropTime / 2);
                            setTimeout(() => {
                                target.dropTime = Math.max(100, 1000 - (target.level - 1) * 100);
                            }, 15000);
                            this.showAttackEffect(target, 'SPEED!');
                        }
                        break;
                        
                    case 'BLIND':
                        if (target) {
                            target.activeEffects.push({ type: 'blind', endTime: Date.now() + 10000 });
                            this.showAttackEffect(target, 'BLIND!');
                        }
                        break;
                        
                    case 'SHIELD':
                        this.activeEffects.push({ type: 'shield', endTime: Date.now() + 30000 });
                        break;
                        
                    case 'CLEAR':
                        for (let i = 0; i < 3; i++) {
                            this.board.pop();
                            this.board.unshift(Array(BOARD_WIDTH).fill(null));
                        }
                        break;
                        
                    case 'SLOW':
                        this.dropTime = Math.min(2000, this.dropTime * 2);
                        setTimeout(() => {
                            this.dropTime = Math.max(100, 1000 - (this.level - 1) * 100);
                        }, 20000);
                        break;
                        
                    case 'ELIMINATE':
                        game.players.forEach(p => {
                            if (p.id !== this.id && !p.gameOver) {
                                // Add 3 rows of garbage properly by pushing existing pieces up
                                for (let i = 0; i < 3; i++) {
                                    const stackLine = Array(BOARD_WIDTH).fill('garbage');
                                    // Create 2-3 random holes per line for fairness
                                    const numHoles = Math.floor(Math.random() * 2) + 2; // 2-3 holes
                                    for (let h = 0; h < numHoles; h++) {
                                        const hole = Math.floor(Math.random() * BOARD_WIDTH);
                                        stackLine[hole] = null;
                                    }
                                    
                                    // Remove top row and add garbage at bottom
                                    // This pushes all pieces up
                                    p.board.shift();
                                    p.board.push(stackLine);
                                    
                                    // Check if pieces reached the top (game over condition)
                                    if (p.board[0].some(cell => cell !== null)) {
                                        p.gameOver = true;
                                    }
                                }
                                this.showAttackEffect(p, 'STACKED!');
                            }
                        });
                        break;
                }
            }

            createLineEffect(y) {
                // This would create visual effects for line clearing
                // Implementation would add DOM elements or canvas effects
            }

            showAttackEffect(target, text) {
                const indicator = document.createElement('div');
                indicator.className = 'attackIndicator';
                indicator.textContent = text;
                const section = document.querySelector(`#player${target.id}`);
                if (section) {
                    section.appendChild(indicator);
                    setTimeout(() => indicator.remove(), 1000);
                }
            }

            getGhostPiece() {
                if (!this.currentPiece) return null;
                
                const ghost = {
                    ...this.currentPiece,
                    y: this.currentPiece.y
                };
                
                while (!this.collides(ghost, 0, 1)) {
                    ghost.y++;
                }
                
                return ghost;
            }

            draw() {
                if (!this.ctx) return;
                
                // Clear canvas
                this.ctx.fillStyle = COLORS.EMPTY;
                this.ctx.fillRect(0, 0, BOARD_WIDTH * BLOCK_SIZE, BOARD_HEIGHT * BLOCK_SIZE);
                
                // Draw board
                for (let y = 0; y < BOARD_HEIGHT; y++) {
                    for (let x = 0; x < BOARD_WIDTH; x++) {
                        if (this.board[y][x]) {
                            this.ctx.fillStyle = this.board[y][x] === 'garbage' ? '#666' : COLORS[this.board[y][x]];
                            this.ctx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE - 1, BLOCK_SIZE - 1);
                        }
                    }
                }

                // Draw decision-making heatmap for AI players
                if (this.isAI && this._debugEvaluations && this._debugEvaluations.length > 0) {
                    // Normalize scores to 0-1 range
                    const scores = this._debugEvaluations.map(e => e.score);
                    const minScore = Math.min(...scores);
                    const maxScore = Math.max(...scores);
                    const range = maxScore - minScore || 1;

                    // Draw heatmap overlays for each evaluated position
                    this._debugEvaluations.forEach(eval => {
                        const normalized = (eval.score - minScore) / range;

                        // Color: red (bad) -> yellow (ok) -> green (good)
                        let r, g, b;
                        if (normalized < 0.5) {
                            // Red to Yellow
                            r = 255;
                            g = Math.floor(255 * (normalized * 2));
                            b = 0;
                        } else {
                            // Yellow to Green
                            r = Math.floor(255 * (1 - (normalized - 0.5) * 2));
                            g = 255;
                            b = 0;
                        }

                        // Draw semi-transparent column highlight
                        this.ctx.fillStyle = `rgba(${r}, ${g}, ${b}, 0.15)`;
                        const height = BOARD_HEIGHT * BLOCK_SIZE;

                        // Highlight the column where this piece would land
                        const width = eval.shape[0].length * BLOCK_SIZE;
                        this.ctx.fillRect(
                            eval.x * BLOCK_SIZE,
                            0,
                            width,
                            height
                        );

                        // Draw small score indicator at top of column (only for best few)
                        if (normalized > 0.8) {
                            this.ctx.fillStyle = `rgba(${r}, ${g}, ${b}, 0.8)`;
                            this.ctx.fillRect(
                                eval.x * BLOCK_SIZE,
                                0,
                                width,
                                4
                            );
                        }
                    });
                }

                // Draw ghost piece
                const ghost = this.getGhostPiece();
                if (ghost && !this.activeEffects.some(e => e.type === 'blind')) {
                    this.ctx.fillStyle = COLORS.GHOST;
                    for (let y = 0; y < ghost.shape.length; y++) {
                        for (let x = 0; x < ghost.shape[y].length; x++) {
                            if (ghost.shape[y][x]) {
                                this.ctx.fillRect(
                                    (ghost.x + x) * BLOCK_SIZE,
                                    (ghost.y + y) * BLOCK_SIZE,
                                    BLOCK_SIZE - 1,
                                    BLOCK_SIZE - 1
                                );
                            }
                        }
                    }
                }
                
                // Draw current piece
                if (this.currentPiece) {
                    this.ctx.fillStyle = COLORS[this.currentPiece.type];
                    for (let y = 0; y < this.currentPiece.shape.length; y++) {
                        for (let x = 0; x < this.currentPiece.shape[y].length; x++) {
                            if (this.currentPiece.shape[y][x]) {
                                this.ctx.fillRect(
                                    (this.currentPiece.x + x) * BLOCK_SIZE,
                                    (this.currentPiece.y + y) * BLOCK_SIZE,
                                    BLOCK_SIZE - 1,
                                    BLOCK_SIZE - 1
                                );
                            }
                        }
                    }
                }
                
                // Draw grid lines
                this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                this.ctx.lineWidth = 0.5;
                for (let i = 0; i <= BOARD_WIDTH; i++) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(i * BLOCK_SIZE, 0);
                    this.ctx.lineTo(i * BLOCK_SIZE, BOARD_HEIGHT * BLOCK_SIZE);
                    this.ctx.stroke();
                }
                for (let i = 0; i <= BOARD_HEIGHT; i++) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, i * BLOCK_SIZE);
                    this.ctx.lineTo(BOARD_WIDTH * BLOCK_SIZE, i * BLOCK_SIZE);
                    this.ctx.stroke();
                }
                
                // Draw game over overlay
                if (this.gameOver) {
                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    this.ctx.fillRect(0, 0, BOARD_WIDTH * BLOCK_SIZE, BOARD_HEIGHT * BLOCK_SIZE);
                    this.ctx.fillStyle = '#fff';
                    this.ctx.font = 'bold 24px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText('GAME OVER', BOARD_WIDTH * BLOCK_SIZE / 2, BOARD_HEIGHT * BLOCK_SIZE / 2);
                }
            }

            update() {
                if (this.gameOver) return;
                
                const now = Date.now();
                
                // Auto drop
                if (now - this.lastDrop > this.dropTime) {
                    this.drop();
                    this.lastDrop = now;
                }
                
                // Update cooldowns
                for (let [key, time] of this.cooldowns) {
                    if (time < now) {
                        this.cooldowns.delete(key);
                    }
                }
                
                // Update effects
                this.activeEffects = this.activeEffects.filter(effect => effect.endTime > now);
                
                // AI logic: plan and execute steps
                if (this.isAI) {
                    if (!this.aiPlan) {
                        if (this.aiType === 'genetic' || (this.aiType === 'mixed' && Math.random() < 0.5)) {
                            this.aiPlan = this.planBestMove();
                        } else if (this.aiType === 'markov' || this.aiType === 'mixed') {
                            this.aiPlan = this.planMarkovMove();
                        }
                    }
                    this.executePlannedStep();
                }
            }

            aiMove() { /* legacy noop retained for compatibility */ }

            executePlannedStep() {
                if (!this.aiPlan || !this.currentPiece) return;
                const now = Date.now();
                if (!this._lastAIStep) this._lastAIStep = 0;
                
                // Consistent AI speed for all AI types - no level-based acceleration for fairness
                const stepDelay = 100; // Shared delay for GA and Markov
                
                if (now - this._lastAIStep < stepDelay) return;
                this._lastAIStep = now;

                // Apply rotation until target rotation reached
                const desiredRotations = this.aiPlan.rotationIndex;
                let currentRotations = 0;
                // Count how many 90-degree rotations from original shape would equal current shape
                // Instead, we can compare by trying to rotate from original
                // For simplicity: just rotate if not at desired count (approx)
                if (this._aiRotationProgress === undefined) this._aiRotationProgress = 0;
                if (this._aiRotationProgress < desiredRotations) {
                    this.rotate();
                    this._aiRotationProgress++;
                    return;
                }

                // Move horizontally toward targetX
                if (this.currentPiece.x < this.aiPlan.targetX) {
                    this.move(1);
                    return;
                }
                if (this.currentPiece.x > this.aiPlan.targetX) {
                    this.move(-1);
                    return;
                }

                // When aligned and rotated, hard drop
                this.hardDrop();
                this._aiRotationProgress = 0;
                this.aiPlan = null;

                // Occasionally use a power-up if available (only when enabled)
                if (game && game.powerUpsEnabled && this.powerUps.length > 0 && Math.random() < 0.15) {
                    const targets = game.players.filter(p => p.id !== this.id && !p.gameOver);
                    if (targets.length > 0) {
                        const target = targets[Math.floor(Math.random() * targets.length)];
                        this.usePowerUp(0, target.id);
                    }
                }
            }

            planBestMove() {
                if (!this.currentPiece) return null;
                const type = this.currentPiece.type;
                const baseShape = PIECES[type];
                const rotations = [];
                rotations.push(baseShape);
                rotations.push(rotateShape(rotations[rotations.length - 1]));
                rotations.push(rotateShape(rotations[rotations.length - 1]));
                rotations.push(rotateShape(rotations[rotations.length - 1]));

                // Deduplicate rotationally equivalent shapes by stringifying
                const uniqueRotations = [];
                const seen = new Set();
                for (let i = 0; i < 4; i++) {
                    const key = JSON.stringify(rotations[i]);
                    if (!seen.has(key)) {
                        seen.add(key);
                        uniqueRotations.push({ shape: rotations[i], rotationIndex: i });
                    }
                }

                let best = null;
                let bestScore = -Infinity;
                const board = this.board;
                const weights = this.aiWeights || DEFAULT_WEIGHTS;

                // Store debug evaluations for visualization
                this._debugEvaluations = [];

                for (const rot of uniqueRotations) {
                    const width = rot.shape[0].length;
                    for (let x = -2; x <= BOARD_WIDTH - 1; x++) { // generous scan window with bounds fix inside simulate
                        const sim = simulateLock(board, type, rot.shape, x);
                        if (!sim) continue;

                        // Fix: Include lines cleared in the evaluation
                        const features = computeBoardFeatures(sim.board);
                        const score = (
                            weights.completeLines * (sim.cleared || 0) +  // Use actual lines cleared!
                            weights.aggregateHeight * features.aggregateHeight +
                            weights.holes * features.holes +
                            weights.bumpiness * features.bumpiness
                        );

                        // Store for visualization
                        this._debugEvaluations.push({
                            x: clampX(x, rot.shape),
                            rotationIndex: rot.rotationIndex,
                            score: score,
                            shape: rot.shape
                        });

                        if (score > bestScore) {
                            bestScore = score;
                            best = { targetX: clampX(x, rot.shape), rotationIndex: rot.rotationIndex };
                        }
                    }
                }

                return best;
            }

            trackHumanMove() {
                // Track intermediate moves for pattern learning
                if (!this.currentPiece) return;
                
                const currentPos = {
                    x: this.currentPiece.x,
                    rotation: this.currentPiece.shape,
                    pieceType: this.currentPiece.type
                };
                
                this.humanMoveHistory.push(currentPos);
            }
            
            recordHumanPlacement() {
                // Record final placement decision by human player
                if (!this.currentPiece || !this.lastHumanState) return;
                
                // Check if this placement will result in line clears
                // Simulate the piece lock to see if lines will be cleared
                const testBoard = cloneBoard(this.board);
                const piece = this.currentPiece;
                
                // Place the piece on the test board
                for (let y = 0; y < piece.shape.length; y++) {
                    for (let x = 0; x < piece.shape[y].length; x++) {
                        if (piece.shape[y][x]) {
                            const boardY = piece.y + y;
                            const boardX = piece.x + x;
                            if (boardY >= 0 && boardY < BOARD_HEIGHT && boardX >= 0 && boardX < BOARD_WIDTH) {
                                testBoard[boardY][boardX] = piece.type;
                            }
                        }
                    }
                }
                
                // Count how many lines will be cleared
                let linesWillClear = 0;
                for (let y = 0; y < BOARD_HEIGHT; y++) {
                    if (testBoard[y].every(cell => cell !== null)) {
                        linesWillClear++;
                    }
                }
                
                // ONLY learn from moves that clear lines
                if (linesWillClear === 0) {
                    // Don't learn from non-line-clearing moves
                    this.humanMoveHistory = [];
                    return;
                }
                
                // Get shared Markov chains instance
                const globalChains = game ? game.markovChains : loadMarkovChains();
                if (!globalChains) return;
                
                // Determine the action taken (final position and rotation)
                const finalX = this.currentPiece.x;
                const rotationCount = this.humanMoveHistory.filter(m => 
                    m.pieceType === this.currentPiece.type
                ).length;
                
                // Simplified rotation index based on shape comparison
                let rotationIndex = 0;
                const baseShape = PIECES[this.currentPiece.type];
                let testShape = baseShape;
                for (let i = 0; i < 4; i++) {
                    if (JSON.stringify(testShape) === JSON.stringify(this.currentPiece.shape)) {
                        rotationIndex = i;
                        break;
                    }
                    testShape = rotateShape(testShape);
                }
                
                const action = actionToString(finalX, rotationIndex);
                const currentState = simplifyBoardToState(this.board, this.currentPiece.type, this.nextPiece);
                
                // Record in human patterns
                if (!globalChains.humanPatterns) {
                    globalChains.humanPatterns = new Map();
                }
                
                if (!globalChains.humanPatterns.has(this.lastHumanState)) {
                    globalChains.humanPatterns.set(this.lastHumanState, new Map());
                }
                
                const stateActions = globalChains.humanPatterns.get(this.lastHumanState);
                const count = stateActions.get(action) || 0;
                stateActions.set(action, count + 1);
                
                // Update transitions with weighted reward based on lines cleared
                // More lines = better reward to learn from
                const baseReward = linesWillClear * 1000;  // 1000 per line cleared
                const bonusForMultiLine = linesWillClear >= 2 ? linesWillClear * 500 : 0;  // Extra bonus for multi-line clears
                const reward = baseReward + bonusForMultiLine;
                
                console.log(`üìö Learning from human: ${linesWillClear} line(s) cleared, reward: ${reward}`);
                
                updateMarkovChain(
                    globalChains,
                    this.lastHumanState,
                    action,
                    currentState,
                    reward
                );
                
                // Clear history for next piece
                this.humanMoveHistory = [];
                globalChains.humanGamesObserved++;
                
                // Save the updated chains
                if (game) {
                    game.markovChains = globalChains;
                }
                saveMarkovChains(globalChains);
            }
            
            planMarkovMove() {
                if (!this.currentPiece) return null;
                
                // Initialize Markov chains if not already done
                if (!this.markovChains) {
                    this.markovChains = game ? game.markovChains : loadMarkovChains();
                }
                
                const currentState = simplifyBoardToState(this.board, this.currentPiece.type, this.nextPiece);
                const pieceType = this.currentPiece.type;
                const possibleActions = generateMarkovPossibleActions(this.board, pieceType);
                
                if (!possibleActions || possibleActions.length === 0) {
                    console.warn('No possible actions for Markov AI');
                    return null;
                }
                
                // Update chain with previous move if we have one
                if (this.lastMarkovState && this.lastMarkovAction) {
                    // Reward previous action using feature deltas (after previous lock vs before it)
                    const featuresAfter = computeBoardFeatures(this.board); // board after last lock
                    const featuresBefore = this.lastFeaturesBefore;          // snapshot taken before that lock
                    const fb = featuresBefore || featuresAfter;

                    // Improvements are positive when after < before for cost features
                    const deltaHeight = fb.aggregateHeight - featuresAfter.aggregateHeight; // positive is good
                    const deltaHoles = fb.holes - featuresAfter.holes;                      // positive is good
                    const deltaBump = fb.bumpiness - featuresAfter.bumpiness;               // positive is good
                    const linesCleared = this.lines - (this.lastMarkovLines || 0);

                    let reward = 0;
                    reward += linesCleared * 200;  // emphasize clears
                    reward += deltaHeight * 2;
                    reward += deltaBump * 1.5;
                    reward += deltaHoles * 50;
                    reward += 2; // small living bonus

                    updateMarkovChain(
                        this.markovChains,
                        this.lastMarkovState,
                        this.lastMarkovAction,
                        currentState,
                        reward
                    );
                }
                
                // Two-ply lookahead using known next piece; fallback to Markov prior if needed
                const selectedAction2Ply = selectActionTwoPly(this.board, pieceType, this.nextPiece, DEFAULT_WEIGHTS, possibleActions);
                const selectedAction = selectedAction2Ply || selectMarkovAction(this.markovChains, currentState, possibleActions, true, this.id, this.board, pieceType);
                const [targetXStr, rotationIndexStr] = selectedAction.split('_');
                const targetX = parseInt(targetXStr);
                const rotationIndex = parseInt(rotationIndexStr);
                
                // Store for next update
                this.lastMarkovState = currentState;
                this.lastMarkovAction = selectedAction;
                this.lastMarkovScore = this.score;
                this.lastMarkovLines = this.lines;
                // Snapshot features before executing the planned placement (used to compute deltas next tick)
                this.lastFeaturesBefore = computeBoardFeatures(this.board);
                
                return { targetX, rotationIndex };
            }
        }

        function clampX(x, shape) {
            if (x < 0) return 0;
            const maxX = BOARD_WIDTH - shape[0].length;
            if (x > maxX) return maxX;
            return x;
        }

        class Game {
            constructor(playerCount, aiType = 'genetic', powerUpsEnabled = true) {
                this.players = [];
                this.playerCount = playerCount;
                this.aiType = aiType;
                this.powerUpsEnabled = powerUpsEnabled;
                this.currentPlayer = 0;
                this.running = false;
                this.lastFrame = 0;
                // GA state
                this.gaState = loadAIWeights(); // { population, index, history }
                this.sessionAIResults = [];
                // Markov chains state - shared across all players for human learning
                this.markovChains = loadMarkovChains();
                // Optional GA population preview UI
                this.populationVis = null;
            }

            init() {
                // Create game container
                const container = document.getElementById('gameContainer');
                container.innerHTML = '';
                
                for (let i = 0; i < this.playerCount; i++) {
                    const versusMode = this.aiType === 'versus';
                    const isMain = (i === 0) && !versusMode;
                    const isAI = versusMode ? true : i > 0;
                    
                    // For mixed mode, alternate between genetic and markov
                    let playerAiType = this.aiType;
                    if (versusMode) {
                        const split = Math.floor(this.playerCount / 2);
                        playerAiType = (i < split) ? 'genetic' : 'markov';
                    } else if (this.aiType === 'mixed' && isAI) {
                        playerAiType = (i % 2 === 1) ? 'genetic' : 'markov';
                    }
                    
                    const player = new Player(i, isAI, playerAiType);
                    this.players.push(player);
                    
                    // Create player section
                    const section = document.createElement('div');
                    section.className = `playerSection ${isMain ? 'main' : ''}`;
                    section.id = `player${i}`;
                    
                    // Header
                    const header = document.createElement('div');
                    header.className = 'playerHeader';
                    let headerText = isMain ? 'YOU' : `CPU ${i}`;
                    if (!isMain) {
                        const aiTypeLabel = playerAiType === 'genetic' ? '(GA)' : '(MC)';
                        headerText += ` ${aiTypeLabel}`;
                    }
                    header.textContent = headerText;
                    section.appendChild(header);
                    
                    // Canvas
                    const canvas = document.createElement('canvas');
                    canvas.width = BOARD_WIDTH * BLOCK_SIZE;
                    canvas.height = BOARD_HEIGHT * BLOCK_SIZE;
                    // All players get same size canvas
                    canvas.className = '';
                    
                    const boardDiv = document.createElement('div');
                    boardDiv.className = 'gameBoard';
                    boardDiv.appendChild(canvas);
                    section.appendChild(boardDiv);
                    
                    // Stats
                    const stats = document.createElement('div');
                    stats.className = 'stats';
                    let statsHTML = `
                        <div><span>Score:</span> <span id="score${i}">0</span></div>
                        <div><span>Lines:</span> <span id="lines${i}">0</span></div>
                        <div><span>Level:</span> <span id="level${i}">1</span></div>
                    `;
                    if (isAI) {
                        statsHTML += `<div><span>PPS:</span> <span id="pps${i}">0.00</span></div>`;
                    }
                    stats.innerHTML = statsHTML;
                    section.appendChild(stats);
                    
                    // Power-ups UI (only for main player and only if enabled)
                    if (isMain && this.powerUpsEnabled) {
                        const powerUpsDiv = document.createElement('div');
                        powerUpsDiv.className = 'powerUpsContainer';
                        powerUpsDiv.id = 'powerUps';
                        section.appendChild(powerUpsDiv);
                        
                        // Target selector
                        const targetDiv = document.createElement('div');
                        targetDiv.className = 'targetSelector';
                        targetDiv.innerHTML = '<div>Target:</div>';
                        const targetButtons = document.createElement('div');
                        
                        for (let j = 1; j < this.playerCount; j++) {
                            const btn = document.createElement('button');
                            btn.className = 'targetButton';
                            btn.textContent = `CPU ${j}`;
                            btn.onclick = () => this.selectTarget(j);
                            if (j === 1) btn.classList.add('selected');
                            targetButtons.appendChild(btn);
                        }
                        
                        targetDiv.appendChild(targetButtons);
                        section.appendChild(targetDiv);
                    }
                    
                    container.appendChild(section);
                    player.init(canvas);

                    // Assign GA genomes to genetic AI players
                    if (isAI && (playerAiType === 'genetic' || playerAiType === 'mixed')) {
                        const genome = this.nextGenome();
                        player.aiWeights = genome.weights;
                        player._genomeId = genome.id;
                    }
                    
                    // Initialize Markov chains for Markov AI players
                    if (isAI && (playerAiType === 'markov' || playerAiType === 'mixed')) {
                        player.markovChains = this.markovChains || loadMarkovChains();
                    }
                }

                // In AI vs AI mode, render GA population preview with mini boards under the main boards
                if (this.aiType === 'versus') {
                    const containerEl = document.getElementById('gameContainer');
                    let panel = document.getElementById('populationPanel');
                    if (!panel) {
                        panel = document.createElement('div');
                        panel.id = 'populationPanel';
                        containerEl.appendChild(panel);
                    }
                    panel.innerHTML = '';
                    const header = document.createElement('div');
                    header.className = 'populationHeader';
                    header.innerHTML = `<span>üß¨ Genetic Population Preview</span><span style="font-weight:400;opacity:.8">(live)</span>`;
                    const grid = document.createElement('div');
                    grid.className = 'populationGrid';
                    panel.appendChild(header);
                    panel.appendChild(grid);

                    this.populationVis = new PopulationVisualizer(grid, this.gaState.population);
                }
                
                // Set initial target for human player only
                if (this.players.length > 1 && !this.players[0].isAI) {
                    this.players[0].target = 1;
                }
                
                this.running = true;
                this.setupControls();
                this.gameLoop();
            }

            nextGenome() {
                const pop = this.gaState.population;
                // Find first unevaluated genome to assign, else wrap around
                for (let i = 0; i < pop.length; i++) {
                    const g = pop[(this.gaState.index + i) % pop.length];
                    if (!g.assigned) {
                        g.assigned = true;
                        this.gaState.index = (this.gaState.index + i + 1) % pop.length;
                        saveAIWeights(this.gaState);
                        return g;
                    }
                }
                // If all assigned, just cycle
                const g = pop[this.gaState.index];
                this.gaState.index = (this.gaState.index + 1) % pop.length;
                saveAIWeights(this.gaState);
                return g;
            }

            selectTarget(targetId) {
                this.players[0].target = targetId;
                document.querySelectorAll('.targetButton').forEach((btn, i) => {
                    btn.classList.toggle('selected', i === targetId - 1);
                });
            }

            setupControls() {
                document.addEventListener('keydown', (e) => {
                    if (!this.running) return;
                    
                    const player = this.players[0];
                    if (player.gameOver) return;
                    
                    switch (e.key) {
                        case 'ArrowLeft':
                            e.preventDefault();
                            player.move(-1);
                            break;
                        case 'ArrowRight':
                            e.preventDefault();
                            player.move(1);
                            break;
                        case 'ArrowDown':
                            e.preventDefault();
                            player.drop();
                            player.score++;
                            break;
                        case 'ArrowUp':
                            e.preventDefault();
                            player.rotate();
                            break;
                        case ' ':
                            e.preventDefault();
                            player.hardDrop();
                            break;
                        case '1':
                        case '2':
                        case '3':
                            if (!this.powerUpsEnabled) break;
                            const index = parseInt(e.key) - 1;
                            if (player.powerUps[index]) {
                                player.usePowerUp(index, player.target);
                                this.updatePowerUps();
                            }
                            break;
                        case 'Tab':
                            if (!this.powerUpsEnabled) break;
                            e.preventDefault();
                            const targets = this.players.filter(p => p.id !== 0 && !p.gameOver);
                            if (targets.length > 0) {
                                const currentIndex = targets.findIndex(t => t.id === player.target);
                                const nextIndex = (currentIndex + 1) % targets.length;
                                this.selectTarget(targets[nextIndex].id);
                            }
                            break;
                    }
                });

                // Touch controls for mobile
                let touchStartX = null;
                let touchStartY = null;
                
                document.addEventListener('touchstart', (e) => {
                    touchStartX = e.touches[0].clientX;
                    touchStartY = e.touches[0].clientY;
                });
                
                document.addEventListener('touchmove', (e) => {
                    if (!touchStartX || !touchStartY) return;
                    
                    const touchEndX = e.touches[0].clientX;
                    const touchEndY = e.touches[0].clientY;
                    
                    const dx = touchEndX - touchStartX;
                    const dy = touchEndY - touchStartY;
                    
                    const player = this.players[0];
                    if (player.gameOver) return;
                    
                    if (Math.abs(dx) > Math.abs(dy)) {
                        if (dx > 50) {
                            player.move(1);
                            touchStartX = touchEndX;
                        } else if (dx < -50) {
                            player.move(-1);
                            touchStartX = touchEndX;
                        }
                    } else {
                        if (dy > 50) {
                            player.drop();
                            touchStartY = touchEndY;
                        }
                    }
                });
                
                document.addEventListener('touchend', (e) => {
                    const touchEndX = e.changedTouches[0].clientX;
                    const touchEndY = e.changedTouches[0].clientY;
                    
                    const dx = touchEndX - touchStartX;
                    const dy = touchEndY - touchStartY;
                    
                    if (Math.abs(dx) < 10 && Math.abs(dy) < 10) {
                        this.players[0].rotate();
                    }
                    
                    touchStartX = null;
                    touchStartY = null;
                });
            }

            updatePowerUps() {
                const container = document.getElementById('powerUps');
                if (!container) return;
                
                container.innerHTML = '';
                const player = this.players[0];
                
                player.powerUps.forEach((powerUp, index) => {
                    const div = document.createElement('div');
                    div.className = 'powerUp';
                    
                    const cooldownTime = player.cooldowns.get(powerUp);
                    if (cooldownTime && cooldownTime > Date.now()) {
                        div.classList.add('cooldown');
                        const remaining = Math.ceil((cooldownTime - Date.now()) / 1000);
                        div.innerHTML = `
                            <div class="cooldownTimer">${remaining}</div>
                        `;
                    } else {
                        div.innerHTML = `
                            <div class="icon">${POWERUPS[powerUp].icon}</div>
                            <div class="name">${POWERUPS[powerUp].name}</div>
                        `;
                        div.onclick = () => {
                            player.usePowerUp(index, player.target);
                            this.updatePowerUps();
                        };
                    }
                    
                    container.appendChild(div);
                });
            }

            updateStats() {
                this.players.forEach(player => {
                    const scoreEl = document.getElementById(`score${player.id}`);
                    const linesEl = document.getElementById(`lines${player.id}`);
                    const levelEl = document.getElementById(`level${player.id}`);
                    const ppsEl = document.getElementById(`pps${player.id}`);
                    
                    if (scoreEl) scoreEl.textContent = player.score;
                    if (linesEl) linesEl.textContent = player.lines;
                    if (levelEl) levelEl.textContent = player.level;
                    if (ppsEl && player.benchmarkStartMs) {
                        const elapsedSec = Math.max((Date.now() - player.benchmarkStartMs) / 1000, 0.001);
                        const pps = player.piecesPlaced / elapsedSec;
                        ppsEl.textContent = pps.toFixed(2);
                    }
                });
            }

            gameLoop(timestamp = 0) {
                if (!this.running) return;
                
                const deltaTime = timestamp - this.lastFrame;
                this.lastFrame = timestamp;
                
                // Update all players
                this.players.forEach(player => {
                    player.update();
                    player.draw();
                });
                
                // Update UI
                this.updateStats();
                if (this.powerUpsEnabled) this.updatePowerUps();
                if (this.populationVis) this.populationVis.update(timestamp, this.players);
                
                // Check for game over
                const alivePlayers = this.players.filter(p => !p.gameOver);
                if (alivePlayers.length <= 1 && this.playerCount > 1) {
                    this.endGame(alivePlayers[0]);
                } else if (alivePlayers.length === 0) {
                    this.endGame(null);
                } else {
                    requestAnimationFrame((t) => this.gameLoop(t));
                }
            }

            endGame(winner) {
                this.running = false;
                
                // Final update to population visualizer to mark dead genomes
                if (this.populationVis) {
                    this.populationVis.update(performance.now(), this.players);
                }
                
                setTimeout(() => {
                    // Update GA fitness for assigned genomes
                    const aiPlayers = this.players.filter(p => p.isAI);
                    aiPlayers.forEach(p => {
                        const fitness = p.score + p.lines * 150; // emphasize lines
                        const genome = this.gaState.population.find(g => g.id === p._genomeId);
                        if (genome) {
                            genome.fitness = Math.max(genome.fitness || 0, fitness);
                            genome.evaluated = true;
                            genome.assigned = false;
                        }
                    });
                    
                    // One more update after marking genomes as evaluated
                    if (this.populationVis) {
                        this.populationVis.update(performance.now(), this.players);
                    }

                    // If all evaluated, evolve a new generation
                    if (this.gaState.population.every(g => g.evaluated)) {
                        this.evolvePopulation();
                    }
                    saveAIWeights(this.gaState);
                    const message = winner ?
                        (winner.isAI ? `CPU ${winner.id} Wins!` : 'You Win!') :
                        'Game Over!';

                    if (confirm(`${message}\n\nPlay again?`)) {
                        location.reload();
                    } else {
                        returnToMenu();
                    }
                }, 1000);
            }

            evolvePopulation() {
                const pop = this.gaState.population.slice().sort((a, b) => b.fitness - a.fitness);
                // Elitism: keep top 1 only (reduced from 2)
                const next = [];
                const eliteCount = Math.min(1, pop.length);
                for (let i = 0; i < eliteCount; i++) {
                    next.push({ id: i, weights: { ...pop[i].weights }, fitness: 0, evaluated: false });
                }
                // Add immigration: inject random genomes to maintain diversity
                if (Math.random() < GA_DEFAULTS.immigrationRate) {
                    for (let i = 0; i < GA_DEFAULTS.immigrationCount && next.length < GA_DEFAULTS.populationSize; i++) {
                        const randomWeights = mutateWeights({ ...DEFAULT_WEIGHTS }, 0.3); // Strong random mutation
                        next.push({ id: next.length, weights: randomWeights, fitness: 0, evaluated: false });
                    }
                }
                
                // Fill rest with offspring via tournament selection + crossover + mutation
                while (next.length < GA_DEFAULTS.populationSize) {
                    const parentA = tournamentSelect(pop);
                    const parentB = tournamentSelect(pop);
                    let childW = crossoverWeights(parentA.weights, parentB.weights);
                    childW = mutateWeights(childW, GA_DEFAULTS.mutationStrength);
                    next.push({ id: next.length, weights: childW, fitness: 0, evaluated: false });
                }
                this.gaState.population = next;
                this.gaState.index = 0;
                this.gaState.history.push({ ts: Date.now(), bestFitness: pop[0]?.fitness || 0 });
                if (this.populationVis) this.populationVis.rebuild(this.gaState.population);
            }
        }

        // --- Population Visualizer: render live mini transparent boards for GA ---
        function createEmptyBoard() {
            return Array.from({ length: BOARD_HEIGHT }, () => Array(BOARD_WIDTH).fill(null));
        }
        function randomPieceType() {
            const keys = Object.keys(PIECES);
            return keys[Math.floor(Math.random() * keys.length)];
        }

        class PopulationVisualizer {
            constructor(rootEl, population) {
                this.root = rootEl;
                this.population = population.slice();
                this.items = []; // { genome, canvas, ctx, sim, dead }
                this.lastStep = 0;
                this.intervalMs = 100; // Faster step rate for more responsive updates
                this.activeGenomes = new Map(); // Track active genome IDs -> player mapping
                this._build();
            }
            rebuild(newPopulation) {
                this.population = newPopulation.slice();
                // Reset all genomes to not dead when rebuilding (new generation)
                this.population.forEach(g => {
                    g.evaluated = false;
                    g.assigned = false;
                });
                this._build();
            }
            _build() {
                this.root.innerHTML = '';
                this.items = [];

                // Calculate population stats for badge assignment
                const evaluatedGenomes = this.population.filter(g => g.fitness != null);
                const sortedByFitness = [...evaluatedGenomes].sort((a, b) => (b.fitness || 0) - (a.fitness || 0));
                const avgFitness = evaluatedGenomes.length > 0
                    ? evaluatedGenomes.reduce((sum, g) => sum + g.fitness, 0) / evaluatedGenomes.length
                    : 0;

                this.population.forEach(genome => {
                    const card = document.createElement('div');
                    card.className = 'miniCard';

                    const label = document.createElement('div');
                    label.className = 'miniLabel';

                    // Determine badge type based on fitness
                    let badgeHTML = '';
                    let cardClass = '';
                    if (genome.fitness != null) {
                        const rank = sortedByFitness.findIndex(g => g.id === genome.id);
                        if (rank >= 0 && rank < 3) {
                            badgeHTML = `<span class="genomeBadge elite">ELITE</span>`;
                            cardClass = 'elite';
                        } else if (genome.fitness >= avgFitness) {
                            badgeHTML = `<span class="genomeBadge avg">AVG</span>`;
                            cardClass = 'avg';
                        } else {
                            badgeHTML = `<span class="genomeBadge low">LOW</span>`;
                            cardClass = 'low';
                        }
                    } else {
                        badgeHTML = `<span class="genomeBadge new">NEW</span>`;
                    }

                    label.innerHTML = `<span>Genome ${genome.id}</span>${badgeHTML}`;
                    if (cardClass) card.classList.add(cardClass);
                    card.appendChild(label);

                    const canvas = document.createElement('canvas');
                    // Keep internal res small; CSS scales
                    canvas.width = BOARD_WIDTH * 10;
                    canvas.height = BOARD_HEIGHT * 10;
                    canvas.className = 'mini';
                    card.appendChild(canvas);

                    const stats = document.createElement('div');
                    stats.className = 'miniStats';
                    stats.textContent = 'lines 0 ¬∑ steps 0';
                    card.appendChild(stats);

                    this.root.appendChild(card);

                    this.items.push({
                        genome,
                        canvas,
                        ctx: canvas.getContext('2d'),
                        statsEl: stats,
                        labelEl: label,
                        card,
                        dead: false,
                        sim: {
                            board: createEmptyBoard(),
                            nextPiece: null,
                            steps: 0,
                            lines: 0
                        }
                    });
                });
            }
            update(ts, players = null) {
                // Update genome status from active players in real-time
                if (players) {
                    this._updateGenomeStatus(players);
                }
                
                if (!this.lastStep) this.lastStep = ts;
                const shouldStep = ts - this.lastStep >= this.intervalMs;
                if (shouldStep) this.lastStep = ts;
                
                this.items.forEach(it => {
                    // Skip dead genomes from simulation but still draw them
                    if (!it.dead && shouldStep) {
                        this._stepSim(it);
                    }
                    this._drawItem(it);
                    
                    // Update stats with real data if available
                    if (it.dead) {
                        it.statsEl.innerHTML = `<span style="color:#ff4444">ELIMINATED</span>`;
                    } else if (it.genome.evaluated) {
                        it.statsEl.innerHTML = `<span style="color:#44ff44">fitness ${it.genome.fitness || 0}</span>`;
                    } else {
                        it.statsEl.textContent = `lines ${it.sim.lines} ¬∑ steps ${it.sim.steps}`;
                    }
                });
            }
            
            _updateGenomeStatus(players) {
                // Track which genomes are actively playing
                const activePlayers = players.filter(p => p.isAI && p._genomeId !== undefined);

                this.items.forEach(item => {
                    const activePlayer = activePlayers.find(p => p._genomeId === item.genome.id);

                    if (activePlayer) {
                        // Genome is actively playing
                        if (activePlayer.gameOver && !item.dead) {
                            // Just died - mark as dead immediately
                            item.dead = true;
                            item.card.classList.remove('playing');
                            item.card.classList.add('dead');
                            // Update the actual genome fitness immediately
                            item.genome.fitness = activePlayer.score + activePlayer.lines * 150;
                            item.genome.evaluated = true;
                        } else if (!activePlayer.gameOver) {
                            // Still playing - update live stats and add playing highlight
                            item.card.classList.add('playing');
                            item.sim.lines = activePlayer.lines;
                            item.sim.steps = activePlayer.piecesPlaced || 0;
                        }
                    } else {
                        // Not actively playing - remove playing class
                        item.card.classList.remove('playing');

                        if (item.genome.evaluated && !item.dead) {
                            // Mark as dead if genome has been evaluated (finished playing)
                            item.dead = true;
                            item.card.classList.add('dead');
                        }
                    }
                });
            }
            _stepSim(item) {
                const { sim, genome } = item;
                // choose piece
                const pieceType = sim.nextPiece || randomPieceType();
                sim.nextPiece = randomPieceType();
                // generate possible actions (reuse helpers)
                const actions = generateMarkovPossibleActions(sim.board, pieceType);
                if (!actions || actions.length === 0) {
                    // If no moves, reset the board for this mini to keep animation going
                    item.sim.board = createEmptyBoard();
                    return;
                }
                // Score each action using genome weights
                let best = null;
                let bestScore = -Infinity;
                for (const a of actions) {
                    const res = evaluatePlacement(sim.board, pieceType, a, genome.weights);
                    if (!res) continue;
                    if (res.score > bestScore) {
                        bestScore = res.score;
                        best = { action: a, cleared: res.cleared };
                    }
                }
                if (!best) return;
                const { x, rotationIndex } = parseActionString(best.action);
                const shape = getRotatedShape(pieceType, rotationIndex);
                const applied = simulateLock(sim.board, pieceType, shape, x);
                if (applied) {
                    sim.board = applied.board;
                    sim.lines += applied.cleared || 0;
                }
                sim.steps++;
            }
            _drawItem(item) {
                const { ctx, canvas, sim, dead } = item;
                const w = canvas.width;
                const h = canvas.height;
                const bs = Math.floor(w / BOARD_WIDTH);
                // Clear and set background based on status
                ctx.clearRect(0, 0, w, h);
                if (dead) {
                    ctx.fillStyle = 'rgba(100,0,0,0.3)'; // Red tint for dead genomes
                } else {
                    ctx.fillStyle = 'rgba(0,0,0,0.25)';
                }
                ctx.fillRect(0, 0, w, h);
                // Grid fade
                ctx.strokeStyle = 'rgba(255,255,255,0.06)';
                ctx.lineWidth = 1;
                for (let x = 0; x <= BOARD_WIDTH; x++) {
                    ctx.beginPath();
                    ctx.moveTo(x * bs + 0.5, 0);
                    ctx.lineTo(x * bs + 0.5, h);
                    ctx.stroke();
                }
                for (let y = 0; y <= BOARD_HEIGHT; y++) {
                    ctx.beginPath();
                    ctx.moveTo(0, y * bs + 0.5);
                    ctx.lineTo(w, y * bs + 0.5);
                    ctx.stroke();
                }
                // Draw blocks
                for (let y = 0; y < BOARD_HEIGHT; y++) {
                    for (let x = 0; x < BOARD_WIDTH; x++) {
                        const cell = sim.board[y][x];
                        if (!cell) continue;
                        ctx.fillStyle = cell === 'garbage' ? 'rgba(160,160,160,0.9)' : COLORS[cell] || '#999';
                        ctx.fillRect(x * bs + 1, y * bs + 1, bs - 2, bs - 2);
                    }
                }
            }
        }

        // LocalTrainer class for automated training with live visualization
        class LocalTrainer {
            constructor() {
                this.running = false;
                this.speed = 1; // 1x, 5x, or MAX
                this.generation = 0;
                this.history = [];
                this.overlay = null;
                this.chart = null;
                this._buildUI();
            }

            _buildUI() {
                // Create overlay
                this.overlay = document.createElement('div');
                this.overlay.className = 'trainer-overlay';
                this.overlay.style.display = 'none';

                this.overlay.innerHTML = `
                    <div class="trainer-header">
                        <div class="trainer-title">üß¨ GA Trainer</div>
                        <div class="trainer-controls">
                            <button class="trainer-btn" id="trainer-minimize">_</button>
                            <button class="trainer-btn danger" id="trainer-close">‚úï</button>
                        </div>
                    </div>
                    <div class="trainer-content">
                        <div class="trainer-stats">
                            <div class="stat-card">
                                <div class="stat-label">Generation</div>
                                <div class="stat-value" id="lab-gen">0</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-label">Best Fitness</div>
                                <div class="stat-value blue" id="lab-best">0</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-label">Avg Fitness</div>
                                <div class="stat-value" id="lab-avg">0</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-label">Diversity</div>
                                <div class="stat-value yellow" id="lab-div">0.00</div>
                            </div>
                        </div>
                        <canvas id="lab-spark" class="trainer-chart" width="360" height="120"></canvas>
                        <div class="progress-text" id="lab-progress">Ready to train</div>
                        <div class="speed-controls">
                            <button class="speed-btn active" data-speed="1">1√ó Speed</button>
                            <button class="speed-btn" data-speed="5">5√ó Speed</button>
                            <button class="speed-btn" data-speed="999">MAX Speed</button>
                        </div>
                        <div class="trainer-controls" style="justify-content: center; margin-top: 15px;">
                            <button class="trainer-btn success" id="trainer-start">‚ñ∂ Start Training</button>
                            <button class="trainer-btn danger" id="trainer-stop" style="display: none;">‚ñ† Stop</button>
                        </div>
                    </div>
                `;

                document.body.appendChild(this.overlay);

                // Setup event listeners
                document.getElementById('trainer-close').onclick = () => this.hide();
                document.getElementById('trainer-minimize').onclick = () => this.toggle();
                document.getElementById('trainer-start').onclick = () => this.start();
                document.getElementById('trainer-stop').onclick = () => this.stop();

                // Speed controls
                document.querySelectorAll('.speed-btn').forEach(btn => {
                    btn.onclick = () => {
                        document.querySelectorAll('.speed-btn').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        this.speed = parseInt(btn.dataset.speed);
                    };
                });

                this.chart = document.getElementById('lab-spark');
            }

            show() {
                this.overlay.style.display = 'block';
                this._renderMetrics();
            }

            hide() {
                this.overlay.style.display = 'none';
                this.stop();
            }

            toggle() {
                this.overlay.classList.toggle('minimized');
            }

            start() {
                if (this.running) return;
                this.running = true;
                document.getElementById('trainer-start').style.display = 'none';
                document.getElementById('trainer-stop').style.display = 'block';
                this._runTrainingLoop();
            }

            stop() {
                this.running = false;
                document.getElementById('trainer-start').style.display = 'block';
                document.getElementById('trainer-stop').style.display = 'none';
            }

            async _runTrainingLoop() {
                while (this.running) {
                    await this._stepGeneration();

                    // Delay based on speed
                    if (this.speed === 1) {
                        await new Promise(resolve => setTimeout(resolve, 2000));
                    } else if (this.speed === 5) {
                        await new Promise(resolve => setTimeout(resolve, 400));
                    }
                    // MAX speed: no delay
                }
            }

            async _stepGeneration() {
                // Load current GA state
                const gaState = JSON.parse(localStorage.getItem('tetris_ai_weights_v2_population') || '{}');
                const population = gaState.population || [];

                if (population.length === 0) {
                    // Initialize population if needed
                    console.log('Initializing population for training...');
                    return;
                }

                // Simulate games for all genomes quickly
                for (let genome of population) {
                    if (!genome.evaluated) {
                        // Quick simulation
                        const fitness = await this._simulateGenome(genome);
                        genome.fitness = fitness;
                        genome.evaluated = true;
                    }
                }

                // Get best fitness
                const best = Math.max(...population.map(g => g.fitness || 0));
                const avg = population.reduce((sum, g) => sum + (g.fitness || 0), 0) / population.length;

                // Record history
                gaState.history = gaState.history || [];
                gaState.history.push({ ts: Date.now(), bestFitness: best });

                // Evolve population
                const newPop = evolvePopulation(population);
                gaState.population = newPop;
                gaState.index = 0;

                // Save
                localStorage.setItem('tetris_ai_weights_v2_population', JSON.stringify(gaState));

                // Update UI
                this.generation++;
                this._renderMetrics();
            }

            async _simulateGenome(genome) {
                // Quick fitness simulation without full game
                // This is a rough estimate based on weights
                const w = genome.weights;
                const balance = Math.abs(w.completeLines) / (Math.abs(w.aggregateHeight) + Math.abs(w.holes) + Math.abs(w.bumpiness) + 0.1);
                const baseFitness = balance * 1000 + Math.random() * 500;
                return Math.floor(baseFitness);
            }

            _renderMetrics() {
                const gaState = JSON.parse(localStorage.getItem('tetris_ai_weights_v2_population') || '{}');
                const population = gaState.population || [];
                const history = gaState.history || [];

                // Calculate metrics
                const evaluatedGenomes = population.filter(g => g.fitness != null);
                const bestFitness = evaluatedGenomes.length > 0
                    ? Math.max(...evaluatedGenomes.map(g => g.fitness))
                    : 0;
                const avgFitness = evaluatedGenomes.length > 0
                    ? Math.round(evaluatedGenomes.reduce((sum, g) => sum + g.fitness, 0) / evaluatedGenomes.length)
                    : 0;

                // Calculate diversity
                let diversity = 0;
                if (population.length >= 2) {
                    let totalDistance = 0;
                    let comparisons = 0;
                    for (let i = 0; i < population.length; i++) {
                        for (let j = i + 1; j < population.length; j++) {
                            const w1 = population[i].weights;
                            const w2 = population[j].weights;
                            if (!w1 || !w2) continue;
                            const dist = Math.sqrt(
                                Object.keys(w1).reduce((sum, key) => {
                                    const diff = (w1[key] || 0) - (w2[key] || 0);
                                    return sum + diff * diff;
                                }, 0)
                            );
                            totalDistance += dist;
                            comparisons++;
                        }
                    }
                    diversity = comparisons > 0 ? totalDistance / comparisons : 0;
                }

                // Update stat displays
                document.getElementById('lab-gen').textContent = history.length;
                document.getElementById('lab-best').textContent = bestFitness.toLocaleString();
                document.getElementById('lab-avg').textContent = avgFitness.toLocaleString();
                document.getElementById('lab-div').textContent = diversity.toFixed(3);

                // Update progress text
                const progressEl = document.getElementById('lab-progress');
                if (this.running) {
                    progressEl.textContent = `Training... (${evaluatedGenomes.length}/${population.length} evaluated)`;
                } else {
                    progressEl.textContent = `Ready ‚Ä¢ ${population.length} genomes in population`;
                }

                // Draw sparkline chart
                this._drawSparkline(history);
            }

            _drawSparkline(history) {
                if (!this.chart || history.length === 0) return;

                const ctx = this.chart.getContext('2d');
                const width = this.chart.width;
                const height = this.chart.height;
                const padding = 10;

                // Clear
                ctx.clearRect(0, 0, width, height);
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.fillRect(0, 0, width, height);

                // Get data
                const dataPoints = history.slice(-50); // Last 50 generations
                if (dataPoints.length < 2) return;

                const maxFitness = Math.max(...dataPoints.map(h => h.bestFitness));
                const minFitness = Math.min(...dataPoints.map(h => h.bestFitness));
                const range = maxFitness - minFitness || 1;

                // Draw line
                ctx.strokeStyle = '#4ade80';
                ctx.lineWidth = 2;
                ctx.beginPath();

                dataPoints.forEach((point, i) => {
                    const x = padding + ((width - 2 * padding) * i) / (dataPoints.length - 1);
                    const y = height - padding - ((height - 2 * padding) * (point.bestFitness - minFitness)) / range;

                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                });

                ctx.stroke();

                // Draw points
                ctx.fillStyle = '#4ade80';
                dataPoints.forEach((point, i) => {
                    const x = padding + ((width - 2 * padding) * i) / (dataPoints.length - 1);
                    const y = height - padding - ((height - 2 * padding) * (point.bestFitness - minFitness)) / range;

                    if (i === dataPoints.length - 1 || i === 0) {
                        ctx.beginPath();
                        ctx.arc(x, y, 3, 0, Math.PI * 2);
                        ctx.fill();
                    }
                });

                // Draw labels
                ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.font = '10px monospace';
                ctx.textAlign = 'left';
                ctx.fillText(`${minFitness}`, 2, height - 2);
                ctx.textAlign = 'right';
                ctx.fillText(`${maxFitness}`, width - 2, 12);
            }
        }

        // Global game instance
        let game = null;
        let localTrainer = null;

        function startGame(playerCount, aiType = 'genetic') {
            try {
                console.log('Starting game with', playerCount, 'players, AI type:', aiType);
                document.getElementById('startMenu').style.display = 'none';
                document.getElementById('gameContainer').style.display = 'flex';
                // Hide controls in AI-vs-AI mode, show floating back button instead
                const isAIvsAI = (aiType === 'versus');
                document.querySelector('.controls').style.display = isAIvsAI ? 'none' : 'block';
                document.getElementById('backToMenuBtn').style.display = isAIvsAI ? 'block' : 'none';

                const powerUpsEnabled = document.getElementById('togglePowerUps') ? document.getElementById('togglePowerUps').checked : true;
                game = new Game(playerCount, aiType, powerUpsEnabled);
                game.init();
            } catch (error) {
                console.error('Error starting game:', error);
                alert('Error starting game: ' + error.message);
                // Reset UI on error
                document.getElementById('startMenu').style.display = 'flex';
                document.getElementById('gameContainer').style.display = 'none';
                document.querySelector('.controls').style.display = 'none';
                document.getElementById('backToMenuBtn').style.display = 'none';
            }
        }

        function returnToMenu() {
            // Stop the current game
            if (game) {
                game.running = false;
                game = null;
            }
            // Hide game UI, show menu
            document.getElementById('gameContainer').style.display = 'none';
            document.getElementById('gameContainer').innerHTML = '';
            document.querySelector('.controls').style.display = 'none';
            document.getElementById('backToMenuBtn').style.display = 'none';
            document.getElementById('startMenu').style.display = 'flex';
        }

        // Global Escape key handler
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && game) {
                returnToMenu();
            }
        });

        // Generation comparison functions
        function showCompareGenerations() {
            const modal = document.getElementById('compareModal');
            modal.style.display = 'flex';

            // Load generation history
            const gaState = JSON.parse(localStorage.getItem('tetris_ai_weights_v2_population') || '{}');
            const history = gaState.history || [];

            if (history.length === 0) {
                alert('No generation history found. Play some games in "Watch Bots Battle" mode to evolve your AI first!');
                modal.style.display = 'none';
                return;
            }

            // Populate dropdowns
            const genASelect = document.getElementById('genA');
            const genBSelect = document.getElementById('genB');

            genASelect.innerHTML = '';
            genBSelect.innerHTML = '';

            // Add generation 0 (initial random)
            const opt0A = document.createElement('option');
            opt0A.value = 0;
            opt0A.textContent = `Gen 0 - Random (Initial)`;
            genASelect.appendChild(opt0A);

            const opt0B = document.createElement('option');
            opt0B.value = 0;
            opt0B.textContent = `Gen 0 - Random (Initial)`;
            genBSelect.appendChild(opt0B);

            // Add evolved generations
            history.forEach((h, idx) => {
                const genNum = idx + 1;
                const optA = document.createElement('option');
                optA.value = genNum;
                optA.textContent = `Gen ${genNum} - Best Fitness: ${h.bestFitness.toLocaleString()}`;
                genASelect.appendChild(optA);

                const optB = document.createElement('option');
                optB.value = genNum;
                optB.textContent = `Gen ${genNum} - Best Fitness: ${h.bestFitness.toLocaleString()}`;
                genBSelect.appendChild(optB);
            });

            // Select first and last by default
            genASelect.value = 0;
            genBSelect.value = history.length;
        }

        function closeCompareModal() {
            document.getElementById('compareModal').style.display = 'none';
        }

        function startGenerationComparison() {
            const genA = parseInt(document.getElementById('genA').value);
            const genB = parseInt(document.getElementById('genB').value);

            closeCompareModal();

            // Start a special comparison game with genomes from both generations
            startComparisonGame(genA, genB);
        }

        function startComparisonGame(genA, genB) {
            try {
                console.log(`Starting generation comparison: Gen ${genA} vs Gen ${genB}`);

                // Hide start menu
                document.getElementById('startMenu').style.display = 'none';
                document.getElementById('gameContainer').style.display = 'flex';
                document.querySelector('.controls').style.display = 'none';

                // Load GA state
                const gaState = JSON.parse(localStorage.getItem('tetris_ai_weights_v2_population') || '{}');

                // Get best genome from each generation
                const weightsA = getGenomeFromGeneration(gaState, genA);
                const weightsB = getGenomeFromGeneration(gaState, genB);

                if (!weightsA || !weightsB) {
                    alert('Could not load genomes from selected generations!');
                    document.getElementById('startMenu').style.display = 'flex';
                    document.getElementById('gameContainer').style.display = 'none';
                    return;
                }

                // Create game with 2 AI players using the selected genomes
                const powerUpsEnabled = false; // Disable power-ups for fair comparison
                game = new Game(2, 'genetic', powerUpsEnabled);

                // Override the genomes for each player
                game.players[0].aiWeights = weightsA;
                game.players[0].playerName = `Gen ${genA} AI`;
                game.players[1].aiWeights = weightsB;
                game.players[1].playerName = `Gen ${genB} AI`;

                // Initialize and start
                game.init();

                // Add generation labels
                setTimeout(() => {
                    const containers = document.querySelectorAll('.playerContainer');
                    if (containers[0]) {
                        const label = document.createElement('div');
                        label.style = 'position: absolute; top: 10px; left: 10px; background: rgba(245,158,11,0.9); padding: 8px 12px; border-radius: 8px; font-weight: bold; z-index: 10;';
                        label.textContent = `Gen ${genA}`;
                        containers[0].style.position = 'relative';
                        containers[0].appendChild(label);
                    }
                    if (containers[1]) {
                        const label = document.createElement('div');
                        label.style = 'position: absolute; top: 10px; left: 10px; background: rgba(245,158,11,0.9); padding: 8px 12px; border-radius: 8px; font-weight: bold; z-index: 10;';
                        label.textContent = `Gen ${genB}`;
                        containers[1].style.position = 'relative';
                        containers[1].appendChild(label);
                    }
                }, 100);

            } catch (error) {
                console.error('Error starting comparison:', error);
                alert('Error starting comparison: ' + error.message);
                document.getElementById('startMenu').style.display = 'flex';
                document.getElementById('gameContainer').style.display = 'none';
            }
        }

        function getGenomeFromGeneration(gaState, genNumber) {
            if (genNumber === 0) {
                // Return random weights for generation 0
                return {
                    aggregateHeight: Math.random() * 2 - 1,
                    completeLines: Math.random() * 2 - 1,
                    holes: Math.random() * 2 - 1,
                    bumpiness: Math.random() * 2 - 1
                };
            }

            // For evolved generations, we need to reconstruct the population at that point
            // For simplicity, we'll use the current population's best genome
            // In a full implementation, we'd store population snapshots
            const population = gaState.population || [];
            if (population.length === 0) return null;

            // Find the best genome
            const sorted = [...population]
                .filter(g => g.fitness != null)
                .sort((a, b) => (b.fitness || 0) - (a.fitness || 0));

            if (sorted.length === 0) return null;

            // For generation comparisons, we could use different genomes
            // For now, return the best genome as a representative
            return sorted[0].weights;
        }

        // Initialize on page load
        window.addEventListener('DOMContentLoaded', () => {
            // Initialize LocalTrainer
            localTrainer = new LocalTrainer();

            // Keyboard shortcut: Press 'T' to toggle trainer
            document.addEventListener('keydown', (e) => {
                if (e.key === 'T' || e.key === 't') {
                    if (localTrainer.overlay.style.display === 'none') {
                        localTrainer.show();
                    } else {
                        localTrainer.hide();
                    }
                }
            });

            console.log('LocalTrainer initialized. Press "T" to open training overlay.');
        });
    </script>
</body>
</html>
