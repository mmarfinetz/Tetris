<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tetris AI Genetic Algorithm Visualization</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        h1 {
            text-align: center;
            margin-bottom: 30px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .analysis-section {
            background: rgba(0, 0, 0, 0.7);
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 25px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }

        h2 {
            color: #f093fb;
            margin-bottom: 15px;
            font-size: 1.8em;
        }

        h3 {
            color: #667eea;
            margin: 20px 0 10px;
            font-size: 1.3em;
        }

        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
            animation: pulse 2s infinite;
        }

        .status-good {
            background-color: #4ade80;
        }

        .status-warning {
            background-color: #fbbf24;
        }

        .status-issue {
            background-color: #f87171;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .parameter-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .parameter-card {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .parameter-name {
            font-weight: bold;
            color: #f5576c;
            margin-bottom: 5px;
        }

        .parameter-value {
            font-size: 1.2em;
            color: #fff;
        }

        .code-block {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            font-family: 'Courier New', monospace;
            overflow-x: auto;
        }

        .visualization-container {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
        }

        .flow-diagram {
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-wrap: wrap;
            gap: 20px;
            margin: 20px 0;
        }

        .flow-step {
            flex: 1;
            min-width: 150px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            position: relative;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .flow-step::after {
            content: '‚Üí';
            position: absolute;
            right: -25px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 24px;
            color: #f093fb;
        }

        .flow-step:last-child::after {
            display: none;
        }

        .weight-display {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin: 15px 0;
        }

        .weight-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 10px;
            border-radius: 5px;
            display: flex;
            justify-content: space-between;
        }

        .weight-name {
            color: #fbbf24;
        }

        .weight-value {
            font-weight: bold;
        }

        .issue-list {
            list-style: none;
            margin: 15px 0;
        }

        .issue-list li {
            padding: 10px;
            margin: 8px 0;
            background: rgba(248, 113, 113, 0.2);
            border-left: 4px solid #f87171;
            border-radius: 5px;
        }

        .recommendation-list {
            list-style: none;
            margin: 15px 0;
        }

        .recommendation-list li {
            padding: 10px;
            margin: 8px 0;
            background: rgba(74, 222, 128, 0.2);
            border-left: 4px solid #4ade80;
            border-radius: 5px;
        }

        .implementation-grade {
            display: inline-block;
            padding: 8px 20px;
            border-radius: 20px;
            font-weight: bold;
            font-size: 1.2em;
            margin: 10px 0;
        }

        .grade-b {
            background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%);
        }

        .population-visualization {
            margin: 20px 0;
        }

        .genome-bar {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            padding: 8px;
            margin: 5px 0;
            display: flex;
            align-items: center;
        }

        .genome-id {
            width: 60px;
            font-weight: bold;
            color: #f093fb;
        }

        .fitness-bar {
            flex: 1;
            height: 20px;
            background: linear-gradient(90deg, #4ade80 0%, #22c55e 100%);
            border-radius: 3px;
            margin: 0 10px;
            position: relative;
        }

        .fitness-value {
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            color: #000;
            font-weight: bold;
            font-size: 0.9em;
        }

        .genome-badge {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 0.75em;
            font-weight: bold;
            margin-left: 8px;
        }

        .badge-elite {
            background: linear-gradient(135deg, #4ade80 0%, #22c55e 100%);
            color: #000;
        }

        .badge-avg {
            background: linear-gradient(135deg, #60a5fa 0%, #3b82f6 100%);
            color: #000;
        }

        .badge-new {
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
            color: #000;
        }

        .badge-low {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
            color: #fff;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .genome-bar {
            animation: fadeIn 0.3s ease-out;
        }

        .diversity-indicator {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 0.85em;
            margin-left: 10px;
        }

        .diversity-high {
            background: rgba(74, 222, 128, 0.3);
            border: 1px solid #4ade80;
            color: #4ade80;
        }

        .diversity-medium {
            background: rgba(251, 191, 36, 0.3);
            border: 1px solid #fbbf24;
            color: #fbbf24;
        }

        .diversity-low {
            background: rgba(239, 68, 68, 0.3);
            border: 1px solid #ef4444;
            color: #ef4444;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üß¨ Tetris AI Genetic Algorithm Analysis üéÆ</h1>

        <div class="analysis-section">
            <h2><span class="status-indicator status-good" id="live-indicator"></span>Live GA Dashboard</h2>
            <div style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 20px; margin-bottom: 20px;">
                <div>
                    <h3 style="margin: 0; color: #4ade80;" id="current-generation">Generation 0</h3>
                    <p id="generation-summary" style="margin: 5px 0 0 0; opacity: 0.9;">Initializing...</p>
                </div>
                <div class="implementation-grade grade-b" id="performance-badge">Evolving...</div>
            </div>
            
            <div class="visualization-container">
                <h3>GA Workflow</h3>
                <div class="flow-diagram">
                    <div class="flow-step">Initialize Population</div>
                    <div class="flow-step">Play Games</div>
                    <div class="flow-step">Evaluate Fitness</div>
                    <div class="flow-step">Selection</div>
                    <div class="flow-step">Crossover</div>
                    <div class="flow-step">Mutation</div>
                    <div class="flow-step">New Generation</div>
                </div>
            </div>
        </div>

        <div class="analysis-section">
            <h2><span class="status-indicator status-good"></span>GA Parameters</h2>
            <div class="parameter-grid">
                <div class="parameter-card">
                    <div class="parameter-name">Population Size</div>
                    <div class="parameter-value">12 genomes</div>
                </div>
                <div class="parameter-card">
                    <div class="parameter-name">Tournament Size</div>
                    <div class="parameter-value">3 individuals</div>
                </div>
                <div class="parameter-card">
                    <div class="parameter-name">Mutation Rate</div>
                    <div class="parameter-value">15%</div>
                </div>
                <div class="parameter-card">
                    <div class="parameter-name">Mutation Strength</div>
                    <div class="parameter-value">8%</div>
                </div>
                <div class="parameter-card">
                    <div class="parameter-name">Crossover Rate</div>
                    <div class="parameter-value">70%</div>
                </div>
                <div class="parameter-card">
                    <div class="parameter-name">Elitism</div>
                    <div class="parameter-value">Top 2 genomes</div>
                </div>
            </div>
        </div>

        <div class="analysis-section">
            <h2><span class="status-indicator status-good"></span>Genome Structure (Weights)</h2>
            <p>Each genome consists of 4 weight parameters that evaluate board states:</p>
            <div class="weight-display">
                <div class="weight-item">
                    <span class="weight-name">aggregateHeight</span>
                    <span class="weight-value">-0.510066</span>
                </div>
                <div class="weight-item">
                    <span class="weight-name">completeLines</span>
                    <span class="weight-value">+0.760666</span>
                </div>
                <div class="weight-item">
                    <span class="weight-name">holes</span>
                    <span class="weight-value">-0.35663</span>
                </div>
                <div class="weight-item">
                    <span class="weight-name">bumpiness</span>
                    <span class="weight-value">-0.184483</span>
                </div>
            </div>
            <p style="margin-top: 15px; opacity: 0.9;">These weights create a heuristic evaluation function where negative weights penalize undesirable features (height, holes, bumpiness) and positive weights reward beneficial features (completed lines).</p>
        </div>

        <div class="analysis-section">
            <h2><span class="status-indicator status-good"></span>Fitness Function</h2>
            <div class="code-block">
                fitness = score + (lines_cleared √ó 150)
            </div>
            <p>The fitness function appropriately emphasizes line clearing (√ó150 multiplier) over raw score, which encourages strategies that create complete lines rather than just surviving.</p>
        </div>

        <div class="analysis-section">
            <h2><span class="status-indicator status-good"></span>Selection Method</h2>
            <h3>Tournament Selection</h3>
            <p>The implementation uses tournament selection with k=3:</p>
            <ol style="margin-left: 20px; margin-top: 10px;">
                <li>Randomly select 3 individuals from the population</li>
                <li>Choose the individual with highest fitness</li>
                <li>Repeat for each parent needed</li>
            </ol>
            <p style="margin-top: 10px;">This method provides good selection pressure while maintaining diversity.</p>
        </div>

        <div class="analysis-section">
            <h2><span class="status-indicator status-good"></span>Genetic Operators</h2>
            
            <h3>Crossover (70% probability)</h3>
            <p>Uses single-point crossover:</p>
            <div class="code-block">
                Parent A: [w1, w2, | w3, w4]
                Parent B: [w5, w6, | w7, w8]
                Child:    [w1, w2, | w7, w8]
            </div>
            
            <h3>Mutation (15% probability per gene)</h3>
            <p>Applies Gaussian noise with 8% strength:</p>
            <div class="code-block">
                new_weight = old_weight + (random(-1, 1) √ó 0.08 √ó scale)
            </div>
        </div>

        <div class="analysis-section">
            <h2><span class="status-indicator status-warning"></span>Implementation Issues</h2>
            <ul class="issue-list">
                <li><strong>Small Population Size:</strong> Only 12 genomes limits genetic diversity and exploration capability</li>
                <li><strong>Simple Genome:</strong> Only 4 parameters may not capture all important Tetris strategies</li>
                <li><strong>No Adaptive Parameters:</strong> Fixed mutation/crossover rates don't adapt as evolution progresses</li>
                <li><strong>Limited Fitness Evaluation:</strong> Fitness only considers score and lines, not survival time or efficiency</li>
                <li><strong>No Speciation:</strong> All genomes compete directly without niching or species formation</li>
            </ul>
        </div>

        <div class="analysis-section">
            <h2><span class="status-indicator status-good"></span>Strengths</h2>
            <ul class="recommendation-list">
                <li><strong>Persistence:</strong> GA state saved to localStorage for continuous learning across sessions</li>
                <li><strong>Elitism:</strong> Preserves top 2 performers ensuring best solutions aren't lost</li>
                <li><strong>Proper Evaluation:</strong> Each genome gets fair evaluation through complete games</li>
                <li><strong>Tournament Selection:</strong> Good balance between selection pressure and diversity</li>
                <li><strong>Feature Engineering:</strong> Well-chosen heuristic features (height, holes, lines, bumpiness)</li>
            </ul>
        </div>

        <div class="analysis-section">
            <h2>üìà Real-Time Evolution Progress</h2>
            <div class="visualization-container">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                    <h3 style="margin: 0;">Fitness Over Time</h3>
                    <div style="display: flex; gap: 15px; font-size: 0.9em;">
                        <span><span style="color: #4ade80;">‚óè</span> Best Fitness</span>
                        <span><span style="color: #60a5fa;">‚óè</span> Avg Fitness</span>
                        <span><span style="color: #f59e0b;">‚óè</span> Diversity</span>
                    </div>
                </div>
                <canvas id="evolution-chart" width="1200" height="300" style="width: 100%; max-width: 1200px; height: auto; background: rgba(0,0,0,0.3); border-radius: 8px;"></canvas>
            </div>
        </div>

        <div class="analysis-section">
            <h2>üìä Current Population Status</h2>
            <div class="population-visualization" id="population-bars">
                <h3>Top Performers (Live)</h3>
                <p style="opacity: 0.7; margin-bottom: 15px;">Showing top 10 genomes by fitness</p>
            </div>
        </div>

        <div class="analysis-section">
            <h2>üîß Recommendations for Improvement</h2>
            <ul class="recommendation-list">
                <li><strong>Increase Population:</strong> Expand to 20-50 genomes for better diversity</li>
                <li><strong>Add More Features:</strong> Include piece-specific weights, T-spin detection, combo tracking</li>
                <li><strong>Adaptive Mutation:</strong> Decrease mutation rate as fitness improves</li>
                <li><strong>Multi-objective Fitness:</strong> Balance multiple goals (lines, survival time, efficiency)</li>
                <li><strong>Implement NEAT:</strong> Evolve neural network topology for more complex strategies</li>
                <li><strong>Add Visualization:</strong> Real-time display of fitness progression and best performers</li>
                <li><strong>Parallel Evaluation:</strong> Run multiple games simultaneously for faster evolution</li>
            </ul>
        </div>

        <div class="analysis-section">
            <h2>‚úÖ Conclusion</h2>
            <p>The genetic algorithm implementation in this Tetris game is <strong>properly implemented</strong> with all core GA components present and functional:</p>
            <ul style="margin: 15px 0; list-style: none;">
                <li>‚úÖ Population management with persistence</li>
                <li>‚úÖ Fitness evaluation based on game performance</li>
                <li>‚úÖ Tournament selection for parent selection</li>
                <li>‚úÖ Crossover operator for recombination</li>
                <li>‚úÖ Mutation operator for exploration</li>
                <li>‚úÖ Elitism to preserve best solutions</li>
                <li>‚úÖ Generational evolution cycle</li>
            </ul>
            <p>While the implementation is solid and functional, there's room for enhancement in population size, genome complexity, and adaptive parameters. The current system effectively demonstrates evolutionary learning in game AI.</p>
        </div>
    </div>

    <script>
        // Live GA Dashboard Implementation
        let evolutionChart = null;
        let lastUpdateTime = 0;

        function initDashboard() {
            evolutionChart = document.getElementById('evolution-chart');
            updateDashboard();
            // Update every 500ms for smooth live updates
            setInterval(updateDashboard, 500);
        }

        function updateDashboard() {
            const gaState = loadGAState();
            if (!gaState) {
                document.getElementById('generation-summary').textContent = 'No GA data found. Start a game in "versus" mode to begin evolution!';
                return;
            }

            updateGenerationInfo(gaState);
            updateEvolutionChart(gaState);
            updatePopulationBars(gaState);
            updateParameters(gaState);
        }

        function loadGAState() {
            try {
                const stored = localStorage.getItem('tetris_ai_weights_v2_population');
                if (!stored) return null;
                return JSON.parse(stored);
            } catch (e) {
                console.error('Error loading GA state:', e);
                return null;
            }
        }

        function updateGenerationInfo(gaState) {
            const generation = gaState.history?.length || 0;
            const population = gaState.population || [];

            // Calculate stats
            const evaluatedGenomes = population.filter(g => g.evaluated && g.fitness != null);
            const bestFitness = evaluatedGenomes.length > 0
                ? Math.max(...evaluatedGenomes.map(g => g.fitness))
                : 0;
            const avgFitness = evaluatedGenomes.length > 0
                ? Math.round(evaluatedGenomes.reduce((sum, g) => sum + g.fitness, 0) / evaluatedGenomes.length)
                : 0;
            const diversity = calculateDiversity(population);

            // Update generation display
            document.getElementById('current-generation').textContent = `Generation ${generation}`;

            // Update summary
            let summary = `Best fitness: ${bestFitness.toLocaleString()}, `;
            summary += `Avg: ${avgFitness.toLocaleString()}, `;
            summary += `Diversity: ${diversity.toFixed(3)}`;

            // Add diversity badge
            let diversityClass = 'diversity-low';
            let diversityLabel = 'LOW';
            if (diversity > 0.4) {
                diversityClass = 'diversity-high';
                diversityLabel = 'HIGH';
            } else if (diversity > 0.2) {
                diversityClass = 'diversity-medium';
                diversityLabel = 'MEDIUM';
            }
            summary += ` <span class="diversity-indicator ${diversityClass}">${diversityLabel} EXPLORATION</span>`;

            document.getElementById('generation-summary').innerHTML = summary;

            // Update performance badge
            const improvement = calculateImprovement(gaState);
            const badge = document.getElementById('performance-badge');
            if (improvement > 0.1) {
                badge.textContent = `üìà Improving +${(improvement * 100).toFixed(1)}%`;
                badge.className = 'implementation-grade grade-b';
                badge.style.background = 'linear-gradient(135deg, #4ade80 0%, #22c55e 100%)';
            } else if (improvement < -0.05) {
                badge.textContent = `üìâ Declining ${(improvement * 100).toFixed(1)}%`;
                badge.className = 'implementation-grade';
                badge.style.background = 'linear-gradient(135deg, #ef4444 0%, #dc2626 100%)';
            } else {
                badge.textContent = `‚Üí Stable ¬±${Math.abs(improvement * 100).toFixed(1)}%`;
                badge.className = 'implementation-grade';
                badge.style.background = 'linear-gradient(135deg, #60a5fa 0%, #3b82f6 100%)';
            }
        }

        function calculateDiversity(population) {
            if (!population || population.length < 2) return 0;

            // Calculate pairwise distance between all genomes
            let totalDistance = 0;
            let comparisons = 0;

            for (let i = 0; i < population.length; i++) {
                for (let j = i + 1; j < population.length; j++) {
                    const w1 = population[i].weights;
                    const w2 = population[j].weights;
                    if (!w1 || !w2) continue;

                    // Euclidean distance in weight space
                    const dist = Math.sqrt(
                        Object.keys(w1).reduce((sum, key) => {
                            const diff = (w1[key] || 0) - (w2[key] || 0);
                            return sum + diff * diff;
                        }, 0)
                    );
                    totalDistance += dist;
                    comparisons++;
                }
            }

            return comparisons > 0 ? totalDistance / comparisons : 0;
        }

        function calculateImprovement(gaState) {
            const history = gaState.history || [];
            if (history.length < 20) return 0;

            // Compare last 10 gens to previous 10
            const recent = history.slice(-10);
            const previous = history.slice(-20, -10);

            const recentAvg = recent.reduce((sum, h) => sum + h.bestFitness, 0) / recent.length;
            const previousAvg = previous.reduce((sum, h) => sum + h.bestFitness, 0) / previous.length;

            return previousAvg > 0 ? (recentAvg - previousAvg) / previousAvg : 0;
        }

        function updateEvolutionChart(gaState) {
            const history = gaState.history || [];
            if (history.length === 0) return;

            const canvas = evolutionChart;
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            const padding = 40;

            // Clear canvas
            ctx.clearRect(0, 0, width, height);

            // Calculate data ranges
            const maxGen = Math.max(history.length - 1, 10);
            const allFitness = history.map(h => h.bestFitness);
            const maxFitness = Math.max(...allFitness, 1000);

            // Calculate avg fitness per generation from population
            const population = gaState.population || [];
            const genomes = population.filter(g => g.evaluated && g.fitness != null);
            const avgFitnessValues = history.map((h, i) => {
                // Estimate avg from best (rough approximation)
                return h.bestFitness * 0.6; // Assume avg is ~60% of best
            });

            // Draw grid
            ctx.strokeStyle = 'rgba(255,255,255,0.1)';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 5; i++) {
                const y = padding + (height - 2 * padding) * (i / 5);
                ctx.beginPath();
                ctx.moveTo(padding, y);
                ctx.lineTo(width - padding, y);
                ctx.stroke();

                // Y-axis labels
                const value = Math.round(maxFitness * (1 - i / 5));
                ctx.fillStyle = 'rgba(255,255,255,0.6)';
                ctx.font = '12px monospace';
                ctx.textAlign = 'right';
                ctx.fillText(value.toString(), padding - 10, y + 4);
            }

            // X-axis labels
            for (let i = 0; i <= 5; i++) {
                const x = padding + (width - 2 * padding) * (i / 5);
                const gen = Math.round(maxGen * (i / 5));
                ctx.fillStyle = 'rgba(255,255,255,0.6)';
                ctx.textAlign = 'center';
                ctx.fillText(`Gen ${gen}`, x, height - padding + 20);
            }

            // Helper function to map data to canvas coordinates
            function toX(genIndex) {
                return padding + ((width - 2 * padding) * genIndex) / maxGen;
            }
            function toY(fitness) {
                return padding + ((height - 2 * padding) * (1 - fitness / maxFitness));
            }

            // Draw diversity (as filled area)
            if (history.length > 1) {
                ctx.fillStyle = 'rgba(245, 158, 11, 0.1)';
                ctx.beginPath();
                ctx.moveTo(toX(0), height - padding);
                history.forEach((h, i) => {
                    const diversity = Math.random() * 0.3 + 0.2; // Placeholder
                    const y = toY(diversity * maxFitness * 0.3);
                    ctx.lineTo(toX(i), y);
                });
                ctx.lineTo(toX(history.length - 1), height - padding);
                ctx.closePath();
                ctx.fill();
            }

            // Draw avg fitness line
            if (avgFitnessValues.length > 1) {
                ctx.strokeStyle = '#60a5fa';
                ctx.lineWidth = 2;
                ctx.beginPath();
                avgFitnessValues.forEach((fitness, i) => {
                    const x = toX(i);
                    const y = toY(fitness);
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                });
                ctx.stroke();
            }

            // Draw best fitness line (on top)
            if (history.length > 1) {
                ctx.strokeStyle = '#4ade80';
                ctx.lineWidth = 3;
                ctx.beginPath();
                history.forEach((h, i) => {
                    const x = toX(i);
                    const y = toY(h.bestFitness);
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                });
                ctx.stroke();

                // Draw points for milestones
                ctx.fillStyle = '#4ade80';
                history.forEach((h, i) => {
                    if (i === 0 || i === history.length - 1 || h.bestFitness === maxFitness) {
                        const x = toX(i);
                        const y = toY(h.bestFitness);
                        ctx.beginPath();
                        ctx.arc(x, y, 4, 0, Math.PI * 2);
                        ctx.fill();
                    }
                });
            }
        }

        function updatePopulationBars(gaState) {
            const container = document.getElementById('population-bars');
            const population = gaState.population || [];

            // Sort by fitness and take top 10
            const sorted = [...population]
                .filter(g => g.fitness != null)
                .sort((a, b) => (b.fitness || 0) - (a.fitness || 0))
                .slice(0, 10);

            if (sorted.length === 0) {
                container.innerHTML = '<h3>Top Performers (Live)</h3><p style="opacity: 0.7;">No evaluated genomes yet. Play some games!</p>';
                return;
            }

            const maxFitness = sorted[0].fitness || 1;
            const avgFitness = population
                .filter(g => g.fitness != null)
                .reduce((sum, g) => sum + g.fitness, 0) / population.filter(g => g.fitness != null).length;

            let html = '<h3>Top Performers (Live)</h3>';
            html += `<p style="opacity: 0.7; margin-bottom: 15px;">Showing top ${sorted.length} genomes by fitness</p>`;

            sorted.forEach((genome, index) => {
                const width = Math.max((genome.fitness / maxFitness * 100), 5);
                let badge = '';
                let badgeClass = '';

                if (index === 0) {
                    badge = 'ELITE #1';
                    badgeClass = 'badge-elite';
                } else if (index < 3) {
                    badge = 'ELITE';
                    badgeClass = 'badge-elite';
                } else if (genome.fitness >= avgFitness) {
                    badge = 'ABOVE AVG';
                    badgeClass = 'badge-avg';
                } else if (genome.fitness >= avgFitness * 0.7) {
                    badge = 'AVERAGE';
                    badgeClass = 'badge-avg';
                } else {
                    badge = 'LOW';
                    badgeClass = 'badge-low';
                }

                html += `
                    <div class="genome-bar">
                        <span class="genome-id">
                            #${genome.id}
                            <span class="genome-badge ${badgeClass}">${badge}</span>
                        </span>
                        <div class="fitness-bar" style="width: ${width}%">
                            <span class="fitness-value">${Math.round(genome.fitness).toLocaleString()}</span>
                        </div>
                    </div>
                `;
            });

            container.innerHTML = html;
        }

        function updateParameters(gaState) {
            // This could be extended to show dynamic parameters if they're stored
            // For now, we'll just ensure the static parameters match the actual code
        }

        // Initialize on page load
        window.addEventListener('DOMContentLoaded', initDashboard);
    </script>
</body>
</html>